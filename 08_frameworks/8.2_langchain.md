## 8.2 LangChain 与 LangGraph：从链到图

LangChain 是智能体开发领域最具影响力的开源项目之一。本节将深入探讨 LangChain 生态的演进，特别是 LangGraph 如何解决了早期架构的局限性，成为构建复杂智能体系统的首选工具。

### 8.2.1 LangChain 的演进

#### 早期：Chain 时代

LangChain 最初的核心抽象是 **链（Chain）**——将多个 LLM 调用串联起来：

```python
# 早期的 LangChain 链式调用

from langchain import LLMChain, PromptTemplate

chain = LLMChain(
    llm=llm,
    prompt=PromptTemplate.from_template("将以下文本翻译成{language}: {text}")
)

result = chain.run(language="英文", text="你好世界")
```

**问题**：Chain 是线性的，无法表达分支、循环和复杂的控制流。

#### 中期：AgentExecutor

为了支持智能体的 ReAct 循环，LangChain 引入了 `AgentExecutor`（智能体执行器）：

```python
from langchain.agents import AgentExecutor, create_react_agent

agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools)

result = executor.invoke({"input": "今天北京天气如何？"})
```

**问题**：AgentExecutor 是个"黑盒"，难以定制控制流、添加中间步骤或实现 Human-in-the-loop。

#### 现在：LangGraph

[LangGraph](https://langchain-ai.github.io/langgraph/) 将工作流建模为 **有向图**，提供了完全的控制力：

```python
from langgraph.graph import StateGraph, END

# 定义图

workflow = StateGraph(AgentState)
workflow.add_node("agent", agent_node)
workflow.add_node("tools", tool_node)

# 定义边（包括条件边）

workflow.add_edge("agent", "tools")
workflow.add_conditional_edges("tools", should_continue, {
    "continue": "agent",
    "end": END
})

# 编译

app = workflow.compile()
```

### 8.2.2 LangGraph 核心概念

#### 状态（State）

状态是贯穿整个图的数据载体：

```python
from typing import TypedDict, Annotated
from operator import add

class AgentState(TypedDict):
    # 消息列表，使用 add 运算符合并

    messages: Annotated[list, add]
    # 当前步骤

    current_step: str
    # 中间结果

    intermediate_results: dict
    # 是否需要人工审批

    needs_approval: bool
```

**状态合并**：LangGraph 支持通过注解定义状态如何更新。`Annotated[list, add]` 表示新消息会追加到列表中，而不是覆盖。

#### 节点（Node）

节点是执行具体逻辑的函数：

```python
def agent_node(state: AgentState) -> AgentState:
    """智能体推理节点"""
    messages = state["messages"]
    
    # 调用 LLM

    response = llm.invoke(messages)
    
    # 解析是否需要调用工具

    if response.tool_calls:
        return {
            "messages": [response],
            "current_step": "tools"
        }
    else:
        return {
            "messages": [response],
            "current_step": "end"
        }

def tool_node(state: AgentState) -> AgentState:
    """工具执行节点"""
    last_message = state["messages"][-1]
    
    results = []
    for tool_call in last_message.tool_calls:
        result = execute_tool(tool_call)
        results.append(ToolMessage(content=result, tool_call_id=tool_call.id))
    
    return {"messages": results}
```

#### 边（Edge）

边定义了节点之间的流转关系：

```python
# 普通边：无条件流转

workflow.add_edge("start", "agent")

# 条件边：根据条件选择下一个节点

def router(state: AgentState) -> str:
    if state["current_step"] == "tools":
        return "tools"
    elif state["needs_approval"]:
        return "human_review"
    else:
        return END

workflow.add_conditional_edges(
    "agent",
    router,
    {
        "tools": "tools",
        "human_review": "human_review",
        END: END
    }
)
```

### 8.2.3 实战：构建客服智能体

#### 需求分析

构建一个客服智能体，具备以下能力：

- 回答常见问题
- 查询订单状态
- 高风险操作需要人工确认
- 支持对话历史

#### 完整实现

具体示例如下：

```python
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage

# 1. 定义状态

class CustomerServiceState(TypedDict):
    messages: Annotated[list, add]
    customer_id: str
    order_id: Optional[str]
    requires_human: bool
    resolved: bool

# 2. 定义工具

@tool
def get_order_status(order_id: str) -> str:
    """查询订单状态"""
    # 模拟数据库查询

    return f"订单 {order_id} 状态：已发货，预计明天送达"

@tool  
def request_refund(order_id: str, reason: str) -> str:
    """申请退款 - 需要人工审批"""
    return f"退款申请已提交，等待人工审核"

tools = [get_order_status, request_refund]

# 3. 定义节点

def customer_service_agent(state: CustomerServiceState):
    messages = state["messages"]
    
    # 添加系统提示

    system_prompt = """你是一个友好的客服助手。
    可用工具：get_order_status（查询订单）、request_refund（申请退款）
    退款操作需要人工确认。"""
    
    response = llm.bind_tools(tools).invoke(
        [{"role": "system", "content": system_prompt}] + messages
    )
    
    # 检查是否需要人工介入

    requires_human = False
    if response.tool_calls:
        for call in response.tool_calls:
            if call["name"] == "request_refund":
                requires_human = True
                
    return {
        "messages": [response],
        "requires_human": requires_human
    }

def execute_tools(state: CustomerServiceState):
    last_message = state["messages"][-1]
    results = []
    
    for tool_call in last_message.tool_calls:
        tool = next(t for t in tools if t.name == tool_call["name"])
        result = tool.invoke(tool_call["args"])
        results.append(ToolMessage(content=result, tool_call_id=tool_call["id"]))
    
    return {"messages": results}

def human_review_node(state: CustomerServiceState):
    """人工审核节点 - 图在此暂停"""
    pass

# 4. 构建图

workflow = StateGraph(CustomerServiceState)

# 添加节点

workflow.add_node("agent", customer_service_agent)
workflow.add_node("tools", execute_tools)
workflow.add_node("human_review", human_review_node)

# 设置入口

workflow.set_entry_point("agent")

# 添加边

def should_continue(state):
    last_message = state["messages"][-1]
    
    if state["requires_human"]:
        return "human_review"
    elif hasattr(last_message, "tool_calls") and last_message.tool_calls:
        return "tools"
    else:
        return END

workflow.add_conditional_edges("agent", should_continue)
workflow.add_edge("tools", "agent")
workflow.add_edge("human_review", "agent")

# 5. 编译（带检查点和中断）

checkpointer = SqliteSaver.from_conn_string(":memory:")
app = workflow.compile(
    checkpointer=checkpointer,
    interrupt_before=["human_review"]  # 人工审核前暂停
)
```

#### 使用示例

具体示例如下：

```python
# 启动对话

config = {"configurable": {"thread_id": "customer_123"}}

# 第一轮：查询订单

response = app.invoke(
    {"messages": [HumanMessage(content="我的订单 ORD-001 到哪了？")]},
    config
)
print(response["messages"][-1].content)
# 输出：订单 ORD-001 状态：已发货，预计明天送达

# 第二轮：申请退款（触发人工审核）

response = app.invoke(
    {"messages": [HumanMessage(content="我要退货")]},
    config
)
# 图在 human_review 节点前暂停

# 人工审核后继续

approval = HumanMessage(content="[人工审核] 批准退款申请")
response = app.invoke({"messages": [approval]}, config)
```

### 8.2.4 高级特性

#### 子图

将复杂逻辑封装为可复用的子图：

```python
# 定义子图

def create_research_subgraph():
    subgraph = StateGraph(ResearchState)
    subgraph.add_node("search", search_node)
    subgraph.add_node("summarize", summarize_node)
    # ...

    return subgraph.compile()

# 在主图中使用

main_graph.add_node("research", create_research_subgraph())
```

#### 流式输出

具体示例如下：

```python
async for event in app.astream_events(input, config, version="v2"):
    if event["event"] == "on_chat_model_stream":
        print(event["data"]["chunk"].content, end="", flush=True)
```

### 8.2.5 小结

LangGraph 的核心优势：

| 特性 | 说明 |
|------|------|
| **图结构** | 支持循环、分支、并行 |
| **状态管理** | 类型安全的状态传递 |
| **检查点** | 支持暂停、恢复、回放 |
| **人机协同** | 原生支持 Human-in-the-loop |
| **可观测性** | 与 LangSmith 深度集成 |

LangGraph 已成为构建生产级智能体的事实标准，下一节将探讨另一个重要框架 LlamaIndex。

---

**下一节**: [LlamaIndex：数据驱动的 RAG 专家](8.3_llamaindex.md)
