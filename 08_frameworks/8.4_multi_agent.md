## 8.4 多体协作：AutoGen 与 CrewAI 实战

单体智能体（Single Agent）受限于上下文窗口和角色的单一性，难以处理极其复杂的任务。这就好比一个人再厉害，也无法独自完成一部电影的拍摄。

**多智能体系统（Multi-Agent System, MAS）** 通过模拟人类团队的协作模式，让多个专注于不同领域的智能体共同解决问题。本节将通过实战案例，深入解析两大主流 MAS 框架：AutoGen 和 CrewAI。

### 8.4.1 AutoGen: 工程师的瑞士军刀

微软推出的 AutoGen 是目前最硬核的多体框架。它的核心特点是 **对话即计算（Conversation as Computation）** 和强大的 **代码执行能力**。

#### 核心概念：UserProxy 与 Assistant

AutoGen 简化了模型，将最基础的交互抽象为两个角色的"二人转"：

1.  **AssistantAgent**: 扮演 AI 助手（如 Python 专家）。它只负责"想"和"写代码"，没有执行环境。
2.  **UserProxyAgent**: 扮演人类代理。它拥有"执行环境"（可以运行 Python 代码或 Shell 命令）。

**工作流**：
1. 任务："请画一张股价走势图"。
2. Assistant: (生成一段 Python 代码)。
3. UserProxy: (自动捕获代码 -> 在本地 Docker 中运行 -> 报错：Module not found)。
4. UserProxy: (将报错信息发回给 Assistant)。
5. Assistant: "抱歉，我忘了安装库。这是修正后的代码..."
6. UserProxy: (运行成功 -> 生成图表文件)。
7. 循环结束。

### 8.4.2 实战：构建自动编程团队

具体示例如下：

```python
import os
from autogen import AssistantAgent, UserProxyAgent, config_list_from_json

# 配置 LLM

config_list = config_list_from_json(env_or_file="OAI_CONFIG_LIST")

# 1. 定义产品经理 Assistant

pm = AssistantAgent(
    name="Product_Manager",
    llm_config={"config_list": config_list},
    system_message="你是一个有创意的产品经理，负责根据用户模糊的需求，构思具体的功能点。"
)

# 2. 定义程序员 Assistant

coder = AssistantAgent(
    name="Coder",
    llm_config={"config_list": config_list},
    system_message="你是一个高级 Python 工程师。你根据 PM 的需求编写代码。代码放在 ```python 代码块中。"
)

# 3. 定义用户代理 UserProxy

# code_execution_config 开启代码执行

user_proxy = UserProxyAgent(
    name="User_Proxy",
    human_input_mode="TERMINATE",  # 只在任务结束或无能为力时请求人类介入
    code_execution_config={"last_n_messages": 2, "work_dir": "groupchat"},
    is_termination_msg=lambda x: x.get("content", "").rstrip().endswith("TERMINATE")
)

# 4. 组建群聊

from autogen import GroupChat, GroupChatManager
groupchat = GroupChat(
    agents=[user_proxy, pm, coder], 
    messages=[], 
    max_round=12
)
manager = GroupChatManager(groupchat=groupchat, llm_config={"config_list": config_list})

# 5. 开始任务

user_proxy.initiate_chat(
    manager,
    message="我想做一个简单的贪吃蛇游戏。"
)
```

**运行结果**：PM 会先列出功能点，Coder 接着写代码，UserProxy 尝试运行，如果报错 Coder 会自动修。你会看到这三个"人"在屏幕上快速刷屏对话，最后直接在目录下生成一个可运行的 `snake.py`。

### 8.4.3 CrewAI: 像导演一样编排团队

如果说 AutoGen 适合极客，那么 CrewAI 就适合产品经理。它更强调 **角色扮演（Role-Playing）** 和 **流程编排（Process Orchestration）**。

#### 核心概念：Agent, Task, Crew

CrewAI 强制要求你思考三个问题：
1. **Who**: 谁来做？(Agent: Role, Goal, Backstory)
2. **What**: 做什么？(Task: Description, Expected Output)
3. **How**: 怎么配合？(Process: Sequential / Hierarchical)

### 8.4.4 实战：构建市场调研团队

具体示例如下：

```python
from crewai import Agent, Task, Crew, Process
from langchain_openai import ChatOpenAI

# 1. 定义角色

# 详细的 Backstory 能显著提升智能体的"代入感"

researcher = Agent(
    role='高级市场研究员',
    goal='揭示人工智能领域的最新趋势和黑马公司',
    backstory="""你是一名在这行干了20年的老兵。
    你擅长从海量的新闻碎片中拼凑出隐藏的市场逻辑。
    你对数据非常敏感，不相信空洞的形容词。""",
    verbose=True,
    allow_delegation=True,  # 允许它把任务分包给别人
    tools=[search_tool]
)

writer = Agent(
    role='科技专栏作家',
    goal='撰写引人入胜的科技故事',
    backstory="""你曾是《连线》杂志的主编。
    你擅长把枯燥的技术报告转化为跌宕起伏的商业故事。
    你的文风犀利、幽默且富有洞察力。""",
    verbose=True
)

# 2. 定义任务

task1 = Task(
    description='全面调研 2024 年 Agentic AI 的 5 大关键趋势。',
    expected_output='一份包含数据支持的趋势列表。',
    agent=researcher
)

task2 = Task(
    description='根据研究员的报告，写一篇深度公众号文章。',
    expected_output='一篇 2000 字的 Markdown 文章，包含引人入胜的标题。',
    agent=writer
)

# 3. 组建团队

crew = Crew(
    agents=[researcher, writer],
    tasks=[task1, task2],
    process=Process.sequential  # 顺序流程：Task1 的输出也就是 Task2 的输入
)

# 4. 开拍

result = crew.kickoff()
print(result)
```

### 8.4.5 AutoGen vs CrewAI

| 维度 | AutoGen | CrewAI |
| :--- | :--- | :--- |
| **强项** | 需要写代码、运行代码的任务 | 需要创意写作、分析、角色扮演的任务 |
| **交互模式** | 对话流（自由度高，易跑偏） | 任务流（结构化强，结果可控） |
| **底层** | 独立实现 | 基于 LangChain |
| **上手难度** | 高（配置复杂） | 低（逻辑直观） |

### 8.4.6 小结

多智能体系统不仅是"人多力量大"，更是 **分而治之** 思想的体现。
- 通过让 Researcher 专注搜索，Writer 专注写作，每个智能体的系统提示词 (System Prompt) 都可以更短、更聚焦，从而降低幻觉，提升质量。
- **AutoGen** 是"代码工厂"，适合构建能干活的软件机器人。
- **CrewAI** 是"创意工作室"，适合构建能思考的内容团队。

下节我们将探讨如何将这些智能体集成到现有的企业系统中。

---

**下一节**: [企业级集成：Semantic Kernel 与现有系统](8.5_enterprise.md)
