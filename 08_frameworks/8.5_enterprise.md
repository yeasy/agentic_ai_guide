## 8.5 企业级集成：Semantic Kernel 与现有系统

在硅谷的创业公司里，你可以用 LangChain 从零构建一切。但在庞大的企业（Enterprise）环境中，由于合规、安全、技术栈限制（如必须用 Java/.NET），引入 Agent 技术往往面临巨大阻力。

微软推出的 **Semantic Kernel (SK)** 正是为了解决这一问题。它不是要颠覆你的现有架构，而是作为**"AI 编排层" (AI Orchardstartion Layer)** 平滑地嵌入到现有系统中。

### 8.5.1 Semantic Kernel 核心理念

SK 的设计极具传统软件工程的美感，它将 LLM 的能力抽象为三个核心概念：

#### 1. Kernel (内核)
系统的核心对象，负责管理所有的资源（模型、记忆、连接器）。它是单例的，像操作系统内核一样调度一切。

#### 2. Plugins (插件)
SK 不叫 Tools，叫 Plugins。这体现了它的定位：**将现有的业务代码"插件化"给 AI 使用**。
- 一个 Plugin 就是一个普通的 C#/Python 类。
- 只要给函数加上 `@kernel_function` 装饰器，它就变成了 AI 可调用的技能。

#### 3. Planner (规划器)
这是 SK 的大脑。Planner 接收用户的自然语言请求（Goal），自动从已注册的 Plugins 中组装出一个执行计划（Plan）。

### 8.5.2 实战：为 ERP 系统添加 AI 助手

假设我们有一个传统的 ERP 系统，现在想给它加一个"自然语言查询库存"的功能。

#### 步骤 1: 定义插件 (Native Function)

你不需要重写业务逻辑，只需要简单封装现有的 API。

```python
from semantic_kernel.functions import kernel_function

class InventoryPlugin:
    @kernel_function(
        description="根据产品ID查询当前库存数量",
        name="GetStockCount"
    )
    def get_stock_count(self, product_id: str) -> int:
        # 这里调用旧系统的 API 或数据库
        print(f"Checking database for {product_id}...")
        return 42

    @kernel_function(
        description="当库存低于阈值时发送补货邮件",
        name="SendRestockEmail"
    )
    def send_restock_email(self, product_id: str, quantity: int) -> str:
        return f"Email sent for {quantity} units of {product_id}"
```

#### 步骤 2: 定义语义函数 (Semantic Function)

有些逻辑适合写代码（如查库），有些逻辑适合问 AI（如写邮件）。SK 允许你把 Prompt 也定义为函数。

```python
# 定义一个写邮件的 Prompt 模板
email_prompt = """
请为产品 {{$product_name}} 写一封补货申请邮件。
当前库存: {{$current_stock}}
建议补货: {{$amount}}
语气: 正式且紧急
"""
```

#### 步骤 3: 初始化 Kernel 并运行

```python
import semantic_kernel as sk
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion

async def main():
    # 1. 初始化 Kernel
    kernel = sk.Kernel()
    
    # 2. 配置 AI 服务 (支持 Azure OpenAI，这对企业很重要)
    service_id = "default"
    kernel.add_service(
        OpenAIChatCompletion(
            service_id=service_id,
            ai_model_id="gpt-4",
            api_key="sk-..."
        )
    )
    
    # 3. 注册插件
    # 导入原生插件
    kernel.import_plugin_from_object(InventoryPlugin(), "Inventory")
    
    # 导入语义插件 (Prompt)
    kernel.create_function_from_prompt(
        function_name="WriteEmail",
        plugin_name="Office",
        prompt=email_prompt
    )
    
    # 4. 自动规划 (Planner)
    from semantic_kernel.planners import FunctionCallingStepwisePlanner
    
    planner = FunctionCallingStepwisePlanner(service_id=service_id)
    
    # 用户的模糊指令
    goal = "查一下 iPhone15 的库存，如果少于 50 台，就写封补货 100 台的邮件。"
    
    # Planner 会自动生成计划并执行
    # Step 1: Call Inventory.GetStockCount("iPhone15") -> Returns 42
    # Step 2: Logic Check (42 < 50)
    # Step 3: Call Office.WriteEmail(name="iPhone15", stock=42, amount=100)
    result = await planner.invoke(kernel, goal)
    
    print(result)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

### 8.5.3 SK 的企业级特性

#### 1. 多语言支持
这是 SK 最大的杀手锏。许多企业后端是 Java 或 C# 写的，引入 Python 的 LangChain 会破坏技术栈。SK 提供了原生的 **C# SDK** 和 **Java SDK**，让后端工程师可以用熟悉的语言开发 Agent。

#### 2. 过滤器 (Filters) - 类似 AOP
SK 支持切面编程（AOP）。你可以定义 `FunctionInvocationFilter`，在任何函数被 AI 调用前后插入逻辑。
- **审计**：记录谁在什么时间调用了什么插件。
- **鉴权**：在调用敏感插件前，检查用户权限。
- **脱敏**：在把数据传给 LLM 前，自动掩盖 PII 信息。

#### 3. 连接器生态
SK 拥有丰富的连接器：
- **向量数据库**: Qdrant, Milvus, Pinecone, Azure AI Search...
- **数据源**: Microsoft Graph (OneDrive, Outlook, Teams)...

这意味着你可以轻松写一个能**读取你的 Outlook 邮件、分析你的 Teams 聊天记录、并把文件存到 OneDrive** 的 Agent。

### 8.5.4 小结

Semantic Kernel 可能不如 LangChain 那么"极客"，也不像 AutoGen 那么"炫酷"，但它是**最懂企业 IT 架构**的框架。

它没有试图重造轮子，而是把 AI 变成了一个可以被标准软件工程调用的**组件**。对于正在进行数字化转型的传统企业，SK 是构建 Copilot 应用的最佳选择，尤其是当你本身就在使用 Microsoft Azure 云技术栈时。

下一章我们将探讨 AgentOps，解决 Agent 上线后的运维、监控和评估问题。

---

**下一节**: [平台级产品：OpenAI Assistants 与 Claude Artifacts](8.6_platforms.md)