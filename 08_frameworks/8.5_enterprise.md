## 8.5 企业级集成：与现有系统整合

在小团队与大型企业环境中，由于合规、安全、技术栈限制（如必须用 Java/.NET），引入智能体技术往往面临巨大阻力。

一类企业级智能体 SDK 正是为了解决这一问题：它们不是要颠覆现有架构，而是作为 **“AI 编排层”** 平滑嵌入既有系统。

### 8.5.1 企业级智能体 SDK 的核心理念

这类 SDK 往往采用传统软件工程的抽象方式，把 LLM 能力组织为可组合的构件：

#### Kernel（内核对象）

系统的核心对象，负责管理所有的资源（模型、记忆、连接器）。它是单例的，像操作系统内核一样调度一切。

#### Plugins（插件化业务能力）

很多企业 SDK 倾向于把工具称为 Plugins（插件），强调复用现有业务代码。这体现了它的定位：**将现有的业务代码“插件化”给 AI 使用**。
- 一个 Plugin 就是一个普通的 C#/Python 类。
- 只要给函数加上 `@kernel_function` 装饰器，它就变成了 AI 可调用的技能。

#### Planner（规划器/编排器）

这是编排层的大脑。Planner 接收用户的自然语言请求 (Goal)，自动从已注册的 Plugins 中组装出一个执行计划 (Plan)。

### 8.5.2 实战：为 ERP 系统添加 AI 助手

假设有一个传统的 ERP 系统，现在想给它加一个“自然语言查询库存”的功能。

#### 步骤 1: 定义插件

你不需要重写业务逻辑，只需要简单封装现有的 API。

```python
from semantic_kernel.functions import kernel_function

class InventoryPlugin:
    @kernel_function(
        description="根据产品ID查询当前库存数量",
        name="GetStockCount"
    )
    def get_stock_count(self, product_id: str) -> int:
        # 这里调用旧系统的 API 或数据库

        print(f"Checking database for {product_id}...")
        return 42

    @kernel_function(
        description="当库存低于阈值时发送补货邮件",
        name="SendRestockEmail"
    )
    def send_restock_email(self, product_id: str, quantity: int) -> str:
        return f"Email sent for {quantity} units of {product_id}"
```

#### 步骤 2: 定义语义函数

有些逻辑适合写代码（如查库），有些逻辑适合问 AI（如写邮件）。这类 SDK 允许你把 Prompt 也定义为函数。

```python
# 定义一个写邮件的 Prompt 模板

email_prompt = """
请为产品 {{$product_name}} 写一封补货申请邮件。
当前库存: {{$current_stock}}
建议补货: {{$amount}}
语气: 正式且紧急
"""
```

#### 步骤 3: 初始化 Kernel 并运行

具体示例如下：

```python
# 伪代码：初始化 Kernel 并注册模型服务

async def main():
    # 1. 初始化 Kernel

    kernel = Kernel()
    
    # 2. 配置 AI 服务

    service_id = "default"
    kernel.add_model_service(ModelService(model="<MODEL>", api_key="<KEY>"))
    
    # 3. 注册插件

    # 导入原生插件

    kernel.import_plugin_from_object(InventoryPlugin(), "Inventory")
    
    # 导入语义插件 (Prompt)

    kernel.create_function_from_prompt(
        function_name="WriteEmail",
        plugin_name="Office",
        prompt=email_prompt
    )
    
    # 4. 自动规划 (Planner)
planner = Planner(model_service="default")
    
    # 用户的模糊指令

    goal = "查询某产品的库存，如果低于阈值，就生成一封补货申请邮件。"
    
    # Planner 会自动生成计划并执行

    # Step 1: Call Inventory.GetStockCount("<product>") -> Returns <count>

    # Step 2: Logic Check (42 < 50)

    # Step 3: Call Office.WriteEmail(name="<product>", stock=<count>, amount=<amount>)

    result = await planner.invoke(kernel, goal)
    
    print(result)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

### 8.5.3 企业级特性

本节将依次介绍“多语言与技术栈适配”与“过滤器：类似 AOP 的机制”等内容。

#### 多语言与技术栈适配

企业级 SDK 往往提供多语言绑定或多运行时支持，便于在既有技术栈内落地。

#### 过滤器：类似 AOP 的机制

这类 SDK 常支持类似切面编程（AOP）的过滤器机制：你可以在任何函数被调用前后插入审计、鉴权、脱敏等逻辑。
- **审计**：记录谁在什么时间调用了什么插件。
- **鉴权**：在调用敏感插件前，检查用户权限。
- **脱敏**：在把数据传给 LLM 前，自动掩盖 PII 信息。

#### 连接器生态

企业落地的关键不只是“能调用工具”，而是能否与身份、权限、审计、数据源连接器体系集成。常见连接器类型包括：

- 结构化数据源（数据库、数据仓库）
- 文档系统与知识库
- 工单/协作系统
- 向量存储与检索服务

### 8.5.4 企业落地常见挑战

企业部署智能体时，难点往往集中在工程与治理，而不是“能不能对话”：

- **与现有系统集成**：身份、权限、数据访问与审计如何统一？
- **数据访问与质量**：数据是否可用、可解释、可追责？
- **变更管理**：流程如何改造、岗位如何协同、如何培训与验收？
- **风险控制**：越权调用、提示词注入、数据泄露如何防护与回溯？

### 8.5.5 小结

企业级智能体 SDK 往往没有“炫技式”的 Demo，但更擅长把智能体能力嵌入现有 IT 架构。

它没有试图重造轮子，而是把 AI 变成了一个可以被标准软件工程调用的 **组件**。对于正在进行数字化转型的传统企业，这类 SDK 往往更适合作为“可治理、可审计、可集成”的智能体基座。

下一节将探讨平台级智能体产品形态，重点对比平台接口与开源框架在能力边界与适用场景上的差异。

---

**下一节**: [8.6 平台级产品：平台接口与工具使用](8.6_platforms.md)
