## 8.6 平台级产品：平台接口与工具使用

除了开源框架，许多模型平台也提供“托管式智能体”能力：包括持久化会话、内置工具、文件处理、以及受控的运行环境。本节讨论平台级产品形态与开源方案的差异与适用场景。

### 8.6.1 托管式智能体接口（形态）

平台级接口通常提供：

- **会话/线程**：持久化对话与状态，减少应用侧的状态管理工作。
- **内置工具**：如代码执行、文件检索、结构化输出等，降低工程门槛。
- **托管运行**：平台负责调度、限流与部分安全策略。

伪代码示例：

```python
client = PlatformClient()
agent = client.create_agent(instructions="...", tools=["code_exec", "file_search"])
thread = client.create_thread()
client.add_message(thread, role="user", content="分析上传的数据")
run = client.run_agent(thread, agent)
result = client.wait(run)
print(result.output_text)
```

### 8.6.2 直接工具调用接口（形态）

另一类平台更强调“模型 + 工具”的直接组合：应用侧自己管理状态，但能更灵活地定义工具与执行策略。

常见模式包括：

- **声明工具 Schema**：用 JSON Schema/类型系统描述工具输入输出。
- **执行与回填**：模型产生工具调用，应用执行后把结果回填到上下文。
- **可插拔执行环境**：需要时引入沙箱（代码执行/浏览器操作），并用权限策略约束风险。

伪代码示例：

```python
client = ModelClient(model="<MODEL>")
tools = [{"name": "get_stock_price", "input_schema": {...}}]
resp = client.generate(messages, tools=tools)
if resp.tool_calls:
    outputs = run_tools(resp.tool_calls)
    resp = client.generate(messages + [resp] + outputs, tools=tools)
```

### 8.6.3 平台对比


#### 能力对比

| 特性 | 托管式接口 | 直接工具调用接口 |
|------|-----------|------------------|
| 状态管理 | 平台托管（线程/会话） | 应用自管（可定制） |
| 内置能力 | 常提供代码执行/文件检索等 | 通常更轻量、更可插拔 |
| 控制粒度 | 中（平台封装较多） | 高（应用侧编排） |
| 运维负担 | 低 | 中到高（取决于工具与沙箱） |

#### 选型建议

**选择托管式接口的场景**：

- 需要快速原型与较少基础设施投入
- 希望平台承担会话、文件与部分工具能力
- 团队更关注产品闭环而非底层编排

**选择直接工具调用接口的场景**：

- 需要更低延迟或更精细的控制
- 工具体系复杂，执行策略需要高度可定制
- 需要把权限/审计/沙箱与内部系统深度整合

**选择开源框架的场景**：

- 需要完全控制权或本地/私有化部署
- 需要支持多模型与多运行环境
- 合规要求高，需要可审计与可移植

### 8.6.4 小结

平台级产品降低了智能体开发的门槛：

| 形态 | 核心优势 | 适用团队 |
|------|----------|----------|
| 托管式接口 | 集成度高、门槛低 | 快速验证或平台化落地 |
| 直接工具调用 | 灵活可控、可插拔 | 有工程能力与复杂工具需求 |
| 开源框架 | 可移植、可治理 | 生产级与合规要求较高 |

选择建议：先用门槛更低的形态验证价值，再在需要时迁移到更可控、可治理的架构。

本章介绍了主流的智能体开发框架，下一章将探讨如何将这些智能体系统工程化落地。

---

**下一节**: [本章小结](summary.md)
