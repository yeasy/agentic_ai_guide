## 6.2 生成式社会模拟：虚拟小镇解析

有代表性的研究工作曾构建一个可交互的虚拟小镇，让多个具备记忆、规划与反思能力的智能体在其中长期运行，展现出“类人”的日常行为与社会关系演化。本节用这一类实验为例，解析生成式社会模拟的关键设计。

### 6.2.1 斯坦福小镇概述

“斯坦福小镇”常被用来指一个典型的生成式社会模拟实验：在一个可交互的虚拟环境中，让多个具备记忆、规划与反思能力的智能体长期运行，并观察其日常行为与社会关系的形成过程。

### 6.2.2 实验设计

一个虚拟小镇环境通常包含：

- **一组 AI 居民**：每人有姓名、职业、性格、人际关系
- **虚拟空间**：咖啡馆、公园、住宅、办公室等场所
- **时间系统**：模拟日夜循环，居民按作息生活
- **交互机制**：居民可以对话、协作、建立关系

#### 环境与时间机制

社会模拟的关键不只是“会聊天”，还在于让智能体处于一个可持续演化的环境里：需要有可推进的时间、可变化的地点状态，以及可被记忆的事件。工程上通常会把“世界状态”做成结构化数据，并为每一步交互记录时间戳，保证行为与记忆可以对齐。

**核心发现**：当给每个智能体足够的记忆和反思能力时，复杂的社会行为会自然涌现。

#### 涌现行为示例

研究中常见的涌现行为：

1. **自发组织派对**：一位智能体决定举办生日派对，自己发邀请、安排时间，其他智能体自发讨论是否参加
2. **信息传播**：一条八卦从 A 传到 B，再传到 C，形成真实的社交网络
3. **情感记忆**：失恋的智能体会避开前任经常出没的地点
4. **协作计划**：多个智能体讨论并共同筹备市长选举活动

### 6.2.3 核心技术架构

本节将依次介绍“记忆流”与“反思机制”等内容。

#### 记忆流

每个智能体维护一个时间顺序的记忆流，记录所有观察和行为：

```python
class MemoryStream:
    def __init__(self):
        self.memories = []  # 按时间顺序存储
        
    def add_memory(
        self, 
        description: str,
        timestamp: datetime,
        importance: float  # 0-10 的重要性评分
    ):
        memory = {
            "description": description,
            "timestamp": timestamp,
            "importance": importance,
            "embedding": embed(description),
            "access_count": 0,
            "last_access": timestamp
        }
        self.memories.append(memory)
```

**记忆检索三要素**：

| 要素 | 说明 | 计算方式 |
|------|------|----------|
| 相关性 | 与当前情境的语义相似度 | Embedding 余弦相似度 |
| 近因性 | 越近的记忆越重要 | 指数衰减函数 |
| 重要性 | 事件的显著程度 | 语言模型打分：0 到 10 |

```python
def retrieve_memories(
    self, 
    query: str, 
    k: int = 10
) -> List[Memory]:
    query_embedding = embed(query)
    
    scored_memories = []
    for memory in self.memories:
        # 相关性分数

        relevance = cosine_similarity(query_embedding, memory["embedding"])
        
        # 近因性分数（指数衰减）

        hours_passed = (now() - memory["timestamp"]).total_seconds() / 3600
        recency = 0.99 ** hours_passed
        
        # 重要性分数（归一化）

        importance = memory["importance"] / 10
        
        # 综合评分

        score = relevance + recency + importance
        scored_memories.append((memory, score))
    
    # 返回 top-k

    scored_memories.sort(key=lambda x: x[1], reverse=True)
    return [m for m, s in scored_memories[:k]]
```

#### 反思机制

智能体定期"反思"自己的记忆，生成更高层次的抽象认知：

```python
async def reflect(self) -> List[str]:
    # 检索最近的重要记忆

    recent_memories = self.retrieve_memories(
        query="最近发生了什么重要的事？",
        k=100
    )
    
    # 提取关键问题

    questions_prompt = f"""
    基于以下记忆，提出 3 个值得深入思考的问题：
    
    记忆：
    {format_memories(recent_memories)}
    """
    questions = await llm.generate(questions_prompt)
    
    # 对每个问题进行反思

    insights = []
    for question in questions:
        relevant_memories = self.retrieve_memories(question, k=20)
        
        insight_prompt = f"""
        问题：{question}
        
        相关记忆：
        {format_memories(relevant_memories)}
        
        基于这些记忆，你能得出什么结论或洞察？
        """
        insight = await llm.generate(insight_prompt)
        
        # 将洞察作为新记忆存储（高重要性）

        self.add_memory(
            description=f"反思：{insight}",
            timestamp=now(),
            importance=8  # 反思通常很重要
        )
        insights.append(insight)
        
    return insights
```

**反思示例**：

```
记忆片段：
- 早上和 Maria 在咖啡馆聊天
- Maria 提到她最近很忙
- 下午看到 Maria 独自在公园散步，看起来很累

反思结论：
"Maria 最近压力很大，可能需要朋友的支持。下次见面应该主动关心她。"
```

#### 规划系统

每个智能体每天会生成日程计划，并根据实际情况动态调整：

```python
async def create_daily_plan(self, agent: Agent) -> List[PlanItem]:
    # 获取智能体的背景信息

    persona = agent.persona
    
    plan_prompt = f"""
    角色：{persona.name}
    职业：{persona.occupation}
    今日日期：{today()}
    
    {persona.name} 的典型日程是什么样的？
    请用简洁的方式列出今天从早到晚的活动计划。
    
    格式：
    时间 | 地点 | 活动
    """
    
    raw_plan = await llm.generate(plan_prompt)
    return parse_plan(raw_plan)
```

**规划的层次性**：

```
高层计划（一天）：
  08:00 - 起床、洗漱
  09:00 - 去咖啡馆工作
  12:00 - 午餐
  ...
  
中层计划（一小时）：
  09:00 - 到达咖啡馆
  09:10 - 点咖啡
  09:20 - 打开笔记本开始写作
  ...
  
低层行动（即时）：
  走向咖啡馆入口 → 开门 → 走到柜台 → 点单 → ...
```

### 6.2.4 对话与社交

社会模拟的关键不只是“每个体会做事”，更在于“个体之间会互动”。对话系统需要结合角色设定、最近经历、关系强度与当前情境，决定是否发起对话、说什么，以及对话如何影响后续行为。

### 6.2.5 自然的对话生成

当两个智能体相遇时，系统会判断是否需要对话：

```python
async def should_initiate_conversation(
    agent1: Agent, 
    agent2: Agent,
    context: str
) -> bool:
    # 检索与对方相关的记忆

    memories_about = agent1.retrieve_memories(
        query=f"关于 {agent2.name} 的记忆",
        k=5
    )
    
    prompt = f"""
    {agent1.name} 刚刚看到了 {agent2.name}。
    
    关于 {agent2.name} 的记忆：
    {format_memories(memories_about)}
    
    当前情境：{context}
    
    {agent1.name} 应该主动打招呼吗？回答 Yes 或 No，并说明理由。
    """
    
    response = await llm.generate(prompt)
    return "yes" in response.lower()
```

### 6.2.6 对话内容生成

对话基于双方的记忆和性格生成：

```python
async def generate_dialogue(
    speaker: Agent,
    listener: Agent,
    conversation_history: List[str]
) -> str:
    # 获取相关记忆

    relevant_memories = speaker.retrieve_memories(
        query=f"与 {listener.name} 的对话",
        k=10
    )
    
    prompt = f"""
    说话者：{speaker.name} ({speaker.persona.traits})
    听者：{listener.name}
    
    相关记忆：
    {format_memories(relevant_memories)}
    
    对话历史：
    {format_history(conversation_history)}
    
    {speaker.name} 接下来会说什么？请保持符合角色性格。
    """
    
    return await llm.generate(prompt)
```

#### 技术启示

对话生成看似简单，但一旦进入多轮、多人物、长时间运行，就会暴露出三个工程要点：

- **记忆检索要稳定**：检索到的片段必须可控且可解释，避免“随机抽到无关记忆”导致对话跑偏。
- **人格与语气要可约束**：性格特征最好结构化（标签或量表），并在提示词中用一致的模板注入。
- **对话要可截断**：对话历史需要摘要与裁剪，否则成本与漂移会快速累积。

#### 工程注意事项

- 为每次对话生成记录 `trace_id`，便于回放与评估。
- 对外部文档与工具输出做注入防护，避免间接指令渗入对话与记忆。
- 为长时间模拟设置“重启与归档策略”，定期整理与合并记忆。

### 6.2.7 对智能体开发的影响

斯坦福小镇的研究提供了重要启示：

1. **记忆是关键**：足够丰富的 **记忆流** 系统是复杂行为涌现的基础
2. **反思产生智慧**：定期反思让智能体能够形成抽象认知
3. **规划带来连贯性**：分层规划让行为更加自然和有目的
4. **简单规则，复杂涌现**：不需要硬编码复杂行为，让其自然涌现

#### 局限性与挑战

- **计算成本高**：每个智能体每天可能需要大量 LLM 调用
- **一致性维护困难**：长时间运行后可能出现人设偏离
- **评估标准模糊**：如何量化"社会行为的真实性"？

#### 落地建议

- 用小规模（少角色、短时间、窄场景）先跑通闭环，再逐步扩展居民数量与环境复杂度。
- 把“记忆写入”与“关键决策”设置为可审计事件，便于定位漂移来源。
- 用回归样例集约束关键行为（例如“遇到熟人要不要打招呼”），把涌现控制在可接受范围内。

### 6.2.8 小结

斯坦福小镇证明了一个重要假设：**当 AI 智能体具备足够的记忆、反思和规划能力时，复杂的社会行为可以自然涌现**。这不仅是一次技术演示，更是对 AI 社会模拟前沿的重要探索。


下一节将探讨博弈论在多智能体系统中的应用。

---

**下一节**: [6.3 博弈论视角下的冲突解决](6.3_game_theory.md)
