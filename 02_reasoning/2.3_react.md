## 2.3 ReAct：推理与行动的统一

ReAct（Reasoning + Acting）是将推理和行动交织在一起的智能体架构范式。它让模型在"思考"和"行动"之间交替进行，是现代 Agent 系统的核心设计模式之一。

### 2.3.1 什么是 ReAct

#### 核心思想

ReAct 的核心是将语言模型的**推理能力**（Chain-of-Thought）与**行动能力**（工具调用）结合起来：

```
Thought: 我需要查找今天的天气预报
Action: search_weather(location="北京")
Observation: 北京今天晴，气温 15-25°C，空气质量良好
Thought: 用户问的是是否需要带伞，根据天气信息...
Action: respond(message="今天北京是晴天，不需要带伞")
```

### 2.3.2 三要素

| 要素 | 说明 | 示例 |
|------|------|------|
| **Thought** | 推理过程，分析当前状态和下一步计划 | "我需要先了解用户的具体需求..." |
| **Action** | 执行的具体操作，通常是工具调用 | `search(query="...")` |
| **Observation** | 行动的结果，来自环境的反馈 | "搜索返回了 5 条相关结果..." |

### 2.3.3 与纯 CoT 的区别

| 维度 | 纯 CoT | ReAct |
|------|--------|-------|
| 信息来源 | 仅模型内部知识 | 可获取外部信息 |
| 执行能力 | 只能推理 | 可以执行操作 |
| 反馈机制 | 无 | 通过 Observation 获得反馈 |
| 适用场景 | 封闭域推理 | 开放域任务 |

#### ReAct 的工作流程

### 2.3.4 基本循环

```python
def react_loop(goal: str, tools: List[Tool], max_steps: int = 10):
    history = []
    
    for step in range(max_steps):
        # 1. 生成 Thought 和 Action
        prompt = format_prompt(goal, history, tools)
        response = model.generate(prompt)
        
        thought, action = parse_response(response)
        history.append({"thought": thought, "action": action})
        
        # 2. 检查是否完成
        if action.type == "finish":
            return action.result
        
        # 3. 执行 Action，获取 Observation
        observation = execute_tool(action, tools)
        history.append({"observation": observation})
    
    return "达到最大步数限制"
```

### 2.3.5 Prompt 模板

```python
REACT_PROMPT = """
你是一个智能助手，可以使用以下工具来完成任务：

{tool_descriptions}

请按照以下格式回答：

Thought: [分析当前情况，思考下一步应该做什么]
Action: [工具名称](参数)
Observation: [工具返回的结果，这部分由系统填充]
... (重复 Thought/Action/Observation 直到完成)
Thought: 我现在知道最终答案了
Action: finish(answer="[最终答案]")

任务：{task}

{history}
"""
```

#### 实际应用示例

#### 示例1：信息查询任务

```
Task: 帮我查一下特斯拉最新的股价，并计算如果我买 100 股需要多少钱

Thought: 我需要先查询特斯拉当前的股价
Action: stock_price(symbol="TSLA")
Observation: TSLA 当前股价: $248.50

Thought: 现在我知道股价是 $248.50，需要计算 100 股的总价
Action: calculator(expression="248.50 * 100")
Observation: 24850.0

Thought: 我已经得到了所需的信息
Action: finish(answer="特斯拉当前股价是 $248.50，购买 100 股需要 $24,850.00")
```

#### 示例2：代码调试任务

```
Task: 帮我分析这个 Python 文件的 bug

Thought: 我需要先读取文件内容
Action: read_file(path="app.py")
Observation: [文件内容...]

Thought: 我看到第 15 行有一个潜在的空指针问题，需要执行代码验证
Action: run_code(code="python app.py")
Observation: TypeError: 'NoneType' object is not subscriptable at line 15

Thought: 确认了 bug 位置，问题是 data 可能为 None。我来修复它
Action: edit_file(path="app.py", line=15, content="if data: result = data['key']")
Observation: 文件已更新

Thought: 重新运行验证修复是否成功
Action: run_code(code="python app.py")
Observation: 程序运行成功，输出: "Hello World"

Thought: Bug 已修复
Action: finish(answer="已修复 app.py 第 15 行的空指针 bug，添加了 None 检查")
```

#### ReAct 的优势

#### 可追溯性

每一步的推理过程都被记录，便于：
- 调试问题
- 理解决策逻辑
- 审计和合规

#### 错误恢复

当 Action 失败时，可以通过 Observation 获得错误信息，然后调整策略：

```
Action: api_call(endpoint="...")
Observation: Error: API rate limit exceeded

Thought: API 限流了，我需要等待后重试或使用备用方案
Action: wait(seconds=60)
```

#### 灵活性

不同于固定流程，ReAct 可以动态调整策略：

```
Thought: 原计划使用 A 方案，但 Observation 显示数据格式不符
Thought: 我需要切换到 B 方案
Action: method_b(...)
```

#### 最佳实践

### 2.3.6 工具设计

```python
# ✅ 好的工具设计
tools = [
    Tool(
        name="search",
        description="搜索网页内容，返回摘要信息",
        parameters={"query": "搜索关键词"}
    ),
    Tool(
        name="calculator", 
        description="执行数学计算",
        parameters={"expression": "数学表达式"}
    )
]

# ❌ 不好的工具设计
tools = [
    Tool(name="do_stuff")  # 名称不明确
]
```

### 2.3.7 Observation 处理

```python
def format_observation(result) -> str:
    # 截断过长的结果
    if len(str(result)) > 1000:
        return str(result)[:1000] + "...[截断]"
    
    # 结构化格式
    if isinstance(result, dict):
        return json.dumps(result, indent=2, ensure_ascii=False)
    
    return str(result)
```

### 2.3.8 错误处理

```python
def execute_with_error_handling(action, tools):
    try:
        result = execute_tool(action, tools)
        return f"Success: {result}"
    except ToolNotFoundError:
        return f"Error: 工具 '{action.tool}' 不存在"
    except Exception as e:
        return f"Error: {type(e).__name__}: {str(e)}"
```

### 2.3.9 常见问题

#### 无限循环

**问题**：Agent 在相同的状态间循环
**解决**：
- 设置最大步数限制
- 检测重复 Action
- 添加循环检测逻辑

#### 过度使用工具

**问题**：简单问题也调用多次工具
**解决**：
- 在 Prompt 中强调效率
- 提供"可以直接回答"的选项

#### 忽略 Observation

**问题**：模型不根据 Observation 调整策略
**解决**：
- 在 Prompt 中强调 Observation 的重要性
- 提供根据 Observation 调整的示例

### 2.3.10 小结

ReAct 架构是现代 Agent 系统的基础范式，它实现了：
- 推理与行动的统一
- 动态环境交互
- 可解释的决策过程

下一节我们将探讨 Reflexion，学习如何让 Agent 从失败中学习和自我改进。

---

**下一节**: [反思与自我修正](2.4_reflexion.md)