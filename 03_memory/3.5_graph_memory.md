## 3.5 图记忆与时序知识图谱

传统的向量数据库在 RAG 场景中表现优异，但随着 Agent 系统的复杂化，其局限性日益明显。2025 年，**图记忆 (Graph Memory)** 和 **时序知识图谱 (Temporal Knowledge Graph, TKG)** 成为记忆系统的重要补充，帮助 Agent 建立更接近人类思维的关联记忆。

### 3.5.1 向量数据库的局限性

#### "数字失忆"问题

向量数据库通过语义相似度检索信息，但存在几个根本性问题：

```
用户：\"上周我提到的那个项目，进展如何？\"

向量检索的困境：
├── ❌ 无法理解 \"上周\" 的时间语义
├── ❌ 无法追踪 \"那个项目\" 的指代关系
├── ❌ 无法关联项目与进展的因果关系
└── ❌ 返回语义相似但上下文无关的文档
```

| 问题 | 向量数据库表现 | 图记忆方案 |
|------|---------------|-----------|
| 时间推理 | ❌ 无时间维度 | ✅ 时序知识图谱 |
| 实体追踪 | ❌ 孤立嵌入 | ✅ 实体节点关联 |
| 关系推理 | ❌ 仅语义相似 | ✅ 显式边关系 |
| 知识演化 | ❌ 静态快照 | ✅ 版本化更新 |

### 3.5.2 时序知识图谱核心概念

时序知识图谱 (TKG) 在传统知识图谱基础上增加了**时间维度**，让 Agent 能够理解"什么时候发生了什么"。

#### 基础结构

```mermaid
graph LR
    subgraph TKG["时序知识图谱"]
        E1["张三<br/>(Person)"]
        E2["项目Alpha<br/>(Project)"]
        E3["v1.0发布<br/>(Event)"]
        E4["项目Beta<br/>(Project)"]
        
        E1 -->|"负责<br/>[2024-01~2024-06]"| E2
        E1 -->|"负责<br/>[2024-07~现在]"| E4
        E2 -->|"产出<br/>[2024-03-15]"| E3
    end
```

#### 核心元素

```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class Entity:
    """知识图谱中的实体节点"""
    id: str
    name: str
    entity_type: str  # Person, Project, Event, Concept...
    attributes: dict
    created_at: datetime
    updated_at: datetime

@dataclass
class Relationship:
    """实体之间的关系边"""
    id: str
    source_id: str
    target_id: str
    relation_type: str  # 负责, 参与, 产出, 依赖...
    attributes: dict
    valid_from: datetime  # 关系生效时间
    valid_to: Optional[datetime]  # 关系失效时间（None=当前有效）

@dataclass
class Episode:
    """一次交互或事件的完整记录"""
    id: str
    content: str
    entities: List[str]  # 涉及的实体ID列表
    relationships: List[str]  # 涉及的关系ID列表
    timestamp: datetime
    source: str  # conversation, document, observation...
```

### 3.5.3 Graphiti：开源图记忆框架

Graphiti 是 Zep 团队开源的时序知识图谱框架，专为 AI Agent 记忆系统设计。

#### 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                      Graphiti 架构                          │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Episode Processing Layer - 处理用户对话/事件           │ │
│  └────────────────────────────────────────────────────────┘ │
│                            │                                 │
│                            ▼                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Knowledge Extraction Layer - LLM 提取实体和关系         │ │
│  └────────────────────────────────────────────────────────┘ │
│                            │                                 │
│                            ▼                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Graph Storage Layer - Neo4j 存储节点和边                │ │
│  └────────────────────────────────────────────────────────┘ │
│                            │                                 │
│                            ▼                                 │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Retrieval Layer - 混合检索（图遍历 + 向量相似度）        │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

#### 基础使用

```python
from graphiti_core import Graphiti
from graphiti_core.nodes import EpisodeType

# 初始化 Graphiti
graphiti = Graphiti(
    neo4j_uri="bolt://localhost:7687",
    neo4j_user="neo4j",
    neo4j_password="password"
)

# 添加一段对话到记忆
await graphiti.add_episode(
    name="用户对话",
    episode_body="""
    用户：我刚加入了项目Alpha团队，负责后端开发。
    助手：欢迎加入！项目Alpha是公司的核心产品，你的后端经验会很有帮助。
    """,
    source=EpisodeType.conversation,
    reference_time=datetime.now()
)

# 检索相关记忆
results = await graphiti.search(
    query="用户在做什么项目？",
    num_results=5
)

for result in results:
    print(f"事实: {result.fact}")
    print(f"相关实体: {result.entities}")
    print(f"时间: {result.valid_at}")
```

#### 知识提取过程

Graphiti 使用 LLM 自动从对话中提取结构化知识：

```python
# 输入对话
episode = "张三说他上周完成了项目Alpha的v1.0版本，现在开始负责项目Beta。"

# LLM 提取的结构化知识
extracted = {
    "entities": [
        {"name": "张三", "type": "Person"},
        {"name": "项目Alpha", "type": "Project"},
        {"name": "v1.0版本", "type": "Release"},
        {"name": "项目Beta", "type": "Project"}
    ],
    "relationships": [
        {
            "source": "张三", 
            "target": "项目Alpha", 
            "type": "完成",
            "valid_at": "上周"
        },
        {
            "source": "项目Alpha",
            "target": "v1.0版本",
            "type": "发布",
            "valid_at": "上周"
        },
        {
            "source": "张三",
            "target": "项目Beta",
            "type": "负责",
            "valid_from": "现在"
        }
    ]
}
```

### 3.5.4 Zep：生产级 Agent 记忆层

Zep 是一个专为 AI Agent 设计的记忆服务，在 Graphiti 基础上提供了完整的生产级方案。

#### 核心特性

```python
from zep_cloud.client import Zep

# 初始化 Zep 客户端
zep = Zep(api_key="your-api-key")

# 创建用户和会话
user = await zep.user.add(user_id="user_123", metadata={"name": "张三"})
session = await zep.memory.add_session(
    session_id="session_456",
    user_id="user_123"
)

# 添加对话记忆
await zep.memory.add(
    session_id="session_456",
    messages=[
        {"role": "user", "content": "我想了解上次讨论的项目进展"},
        {"role": "assistant", "content": "根据上次对话，您负责的项目Alpha..."}
    ]
)

# 智能检索（结合对话历史 + 知识图谱 + 时间推理）
context = await zep.memory.get(
    session_id="session_456",
    min_rating=0.5,  # 相关性阈值
    lastn=10         # 最近N条消息
)
```

#### 与向量数据库的性能对比

| 指标 | 纯向量检索 | Zep (TKG) |
|------|-----------|-----------|
| 事实准确率 | 72% | 94% |
| 时间推理准确率 | 45% | 89% |
| 响应延迟 | 120ms | 85ms |
| 幻觉率 | 18% | 6% |

### 3.5.5 图记忆 vs RAG：如何选择

两种技术并非互斥，而是互补：

```
┌─────────────────────────────────────────────────────────────┐
│                     混合记忆架构                             │
│                                                              │
│   用户查询                                                   │
│       │                                                      │
│       ├──────────────┬──────────────┐                       │
│       ▼              ▼              ▼                       │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                 │
│  │ 图记忆   │    │ 向量RAG │    │ 全文搜索 │                 │
│  │ (关系)   │    │ (语义)  │    │ (关键词) │                 │
│  └─────────┘    └─────────┘    └─────────┘                 │
│       │              │              │                       │
│       └──────────────┼──────────────┘                       │
│                      ▼                                       │
│              ┌─────────────┐                                │
│              │  结果融合    │                                │
│              │  Reranking  │                                │
│              └─────────────┘                                │
│                      │                                       │
│                      ▼                                       │
│              最终上下文                                       │
└─────────────────────────────────────────────────────────────┘
```

| 场景 | 推荐方案 |
|------|---------|
| 静态知识库问答 | 向量 RAG |
| 长期用户交互 | 图记忆 |
| 多实体关系推理 | 图记忆 |
| 文档语义检索 | 向量 RAG |
| 时间相关查询 | 图记忆 |
| 混合场景 | 图记忆 + 向量 RAG |

### 3.5.6 实战：为 Agent 添加图记忆

```python
from typing import List, Dict
from graphiti_core import Graphiti

class GraphMemoryAgent:
    """带有图记忆能力的 Agent"""
    
    def __init__(self, llm, graphiti: Graphiti):
        self.llm = llm
        self.memory = graphiti
    
    async def chat(self, user_id: str, message: str) -> str:
        # 1. 检索相关记忆
        memories = await self.memory.search(
            query=message,
            num_results=10,
            filters={"user_id": user_id}
        )
        
        # 2. 构建增强上下文
        memory_context = self._format_memories(memories)
        
        # 3. 生成回复
        response = await self.llm.generate(f"""
        你是一个有记忆的智能助手。
        
        用户历史记忆：
        {memory_context}
        
        用户问题：{message}
        
        基于历史记忆回答问题。如果记忆中没有相关信息，如实说明。
        """)
        
        # 4. 将本次对话存入记忆
        await self.memory.add_episode(
            name=f"对话-{user_id}",
            episode_body=f"用户：{message}\n助手：{response}",
            source=EpisodeType.conversation,
            reference_time=datetime.now()
        )
        
        return response
    
    def _format_memories(self, memories: List) -> str:
        """格式化记忆为上下文"""
        if not memories:
            return "暂无相关历史记忆。"
        
        formatted = []
        for m in memories:
            formatted.append(
                f"- [{m.valid_at}] {m.fact} (相关实体: {', '.join(m.entities)})"
            )
        return "\n".join(formatted)
```

### 3.5.7 小结

图记忆和时序知识图谱代表了 Agent 记忆系统的下一代架构：

| 特性 | 向量数据库 | 图记忆 (TKG) |
|------|-----------|-------------|
| 数据模型 | 扁平嵌入 | 节点+边+时间 |
| 检索方式 | 语义相似度 | 图遍历+语义 |
| 时间感知 | ❌ | ✅ |
| 关系推理 | ❌ | ✅ |
| 知识演化 | 覆盖更新 | 版本化追踪 |
| 适用场景 | 静态知识 | 动态交互 |

**核心洞察**：
1. **向量检索擅长"找相似"**，图记忆擅长"理解关系"
2. **时间维度是关键**：Agent 需要理解"什么时候发生了什么"
3. **两者互补**：生产系统通常需要混合架构
4. **框架选择**：Graphiti 适合自建，Zep 适合快速上手

---

**下一节**: [本章小结](summary.md)
