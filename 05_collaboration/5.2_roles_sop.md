## 5.2 角色分工与 SOP 流程编排

在多智能体系统中，明确的角色定义和标准化的工作流程是高效协作的基础。本节探讨如何为每个智能体设计独特的"人设"，以及如何通过 **标准作业程序（Standard Operating Procedure, SOP）** 来编排复杂的协作流程。

#### 角色定义：智能体的身份证

每个智能体都应该拥有一张独特的"身份证"，包含以下核心要素：

### 5.2.1 角色 (Role)

角色定义了智能体的职能边界。如同公司中的职位，角色决定了智能体应该做什么、不应该做什么。

```python
class AgentRole:
    def __init__(self):
        self.name = "首席架构师"
        self.department = "技术部"
        self.permissions = ["代码审查", "架构决策", "技术选型"]
        self.restrictions = ["不参与招聘", "不处理财务"]
```

**设计原则**：角色应该足够具体，避免"万能智能体"。一个好的角色定义应该能回答"这个智能体负责什么？不负责什么？"

#### 目标 (Goal)

目标是智能体的 KPI，驱动其行为方向。目标应该是可衡量的、具体的。

**好的目标示例**：
- "将用户需求转化为不超过 10 个的技术任务项"
- "确保代码覆盖率达到 80% 以上"
- "在 5 轮对话内解决用户问题"

**差的目标示例**：
- "做好工作"（太模糊）
- "成为最好的助手"（无法衡量）

#### 背景故事 (Backstory)

背景故事看似"软性"，但实际上能显著影响 LLM 的输出风格和决策倾向。这是利用模型"角色扮演"能力的关键技巧。

```python
backstory = """
你是一位在 Google 工作了 10 年的资深架构师。你崇尚简洁的代码风格，
讨厌过度工程化。你总是先问"这真的有必要吗？"再动手实现。
在技术争论中，你习惯用数据和案例说话，而不是诉诸权威。
"""
```

**研究发现**：给模型一个详细的背景故事，可以让其输出更加一致和可预测。这是因为背景故事为模型提供了决策的参考框架。

### 5.2.2 标准作业程序 设计

SOP 定义了多个智能体如何按照预定流程协作完成任务。

### 5.2.3 SOP 的核心要素

1. **触发条件**：什么情况下启动这个流程？
2. **参与角色**：哪些智能体参与？
3. **执行步骤**：每一步做什么？谁来做？
4. **交接规则**：步骤之间如何传递信息？
5. **终止条件**：什么情况下流程结束？

### 5.2.4 MetaGPT 的 SOP 实践

[MetaGPT](https://github.com/geekan/MetaGPT) 是将 SOP 理念发挥到极致的多智能体框架。它模拟了一个完整的软件公司：

```
用户需求 → 产品经理(PRD) → 架构师(设计文档) → 工程师(代码) → QA(测试)
```

每个角色都有明确的输入输出规范：

| 角色 | 输入 | 输出 | 质量标准 |
|------|------|------|----------|
| 产品经理 | 用户原始需求 | 产品需求文档 (PRD) | 需求完整性 |
| 架构师 | PRD 文档 | 系统设计图 | 架构合理性 |
| 工程师 | 设计文档 | 可运行代码 | 代码质量 |
| QA | 代码 | 测试报告 | 测试覆盖率 |

#### 实现 SOP 的代码模式

```python
class SoftwareDevelopmentSOP:
    def __init__(self):
        self.agents = {
            "pm": ProductManagerAgent(),
            "architect": ArchitectAgent(),
            "developer": DeveloperAgent(),
            "qa": QAAgent()
        }
        
    async def execute(self, user_requirement: str):
        # Step 1: 需求分析
        prd = await self.agents["pm"].analyze(user_requirement)
        
        # Step 2: 架构设计
        design = await self.agents["architect"].design(prd)
        
        # Step 3: 代码实现
        code = await self.agents["developer"].implement(design)
        
        # Step 4: 质量测试
        report = await self.agents["qa"].test(code)
        
        # 如果测试失败，回到开发阶段
        if not report.passed:
            code = await self.agents["developer"].fix(code, report.issues)
            
        return code, report
```

### 5.2.5 工具权限分配

在多智能体系统中，工具权限的分配是角色设计的重要组成部分。不同角色应该只能访问与其职能相关的工具。

### 5.2.6 权限矩阵设计

```python
PERMISSION_MATRIX = {
    "product_manager": ["search_web", "read_document", "create_prd"],
    "architect": ["search_code", "draw_diagram", "analyze_dependency"],
    "developer": ["write_code", "run_tests", "git_commit"],
    "qa": ["run_tests", "generate_report", "create_issue"],
    "hr": ["search_employee", "send_email", "schedule_meeting"]
}

def get_tools_for_agent(role: str) -> List[Tool]:
    allowed_tools = PERMISSION_MATRIX.get(role, [])
    return [tool for tool in ALL_TOOLS if tool.name in allowed_tools]
```

**安全原则**：最小权限原则。每个智能体只应该拥有完成其任务所必需的最少权限，避免越权操作带来的风险。

### 5.2.7 角色设计的常见失败模式

2025 年的一项针对多智能体系统的大规模研究《[Why Do Multi-Agent LLM Systems Fail?](https://arxiv.org/abs/2503.13657)》分析了 1642 条执行轨迹，揭示了主流框架 41%-86.7% 的失败率。研究提出了 **MAST（Multi-Agent System Failure Taxonomy）** 分类法，其中与角色设计直接相关的是 **FC1：系统设计问题**。

#### 系统设计问题（FC1）的典型失败模式

| 失败模式 | 发生率 | 描述 |
|---------|--------|------|
| **FM-1.1 违反任务规范** | 11.8% | 智能体未能遵循用户指定的任务要求 |
| **FM-1.2 违反角色规范** | 1.5% | 智能体行为超出其定义的角色边界 |
| **FM-1.3 步骤重复** | 15.7% | 智能体陷入重复执行相同步骤的循环 |
| **FM-1.4 上下文丢失** | 2.8% | 对话历史信息在执行过程中丢失 |
| **FM-1.5 无法识别停止条件** | 12.4% | 智能体无法判断任务何时完成 |

#### 案例：角色规范优化的效果

研究发现，即使使用相同的底层模型（GPT-4o），仅通过改进智能体的角色规范设计，ChatDev 框架的成功率就提升了 **+9.4%**。这说明系统设计往往比模型选择更重要。

**优化建议**：

1. **明确终止条件**：在角色定义中显式说明"什么情况下任务完成"，避免 FM-1.5。
2. **防止步骤重复**：设置最大迭代次数，并在 Prompt 中提醒智能体 "不要重复已完成的步骤"。
3. **职责边界清晰**：使用 `restrictions` 字段明确禁止的行为，降低 FM-1.2 风险。

### 5.2.8 小结

角色分工和 SOP 是多智能体系统的"组织架构"。通过精心设计角色定义（Role + Goal + Backstory）和标准化流程（SOP），我们可以：

- 让每个智能体专注于自己擅长的领域
- 减少角色冲突和职责模糊
- 提高复杂任务的完成质量
- 便于系统的调试和维护

下一节我们将探讨如何让这些角色动态组队，应对更加复杂多变的任务场景。

---

**下一节**: [动态组队与自适应编排](5.3_dynamic_teaming.md)