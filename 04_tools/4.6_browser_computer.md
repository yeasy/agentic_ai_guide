## 4.6 浏览器自动化与 Computer Use

浏览器自动化和 Computer Use 代表了 Agent 与数字环境深度交互的最高形态。它们让 AI 能够像人类一样操作网页、控制桌面应用，从而完成传统 API 无法触及的任务——比如在一个只有网页界面的旧系统中填写表单。

#### 为什么需要 UI 自动化

#### API 的局限性

并非所有系统都提供 API：
- **遗留系统**：企业内部的 ERP、CRM 系统往往只有 Web 界面。
- **第三方服务**：很多 SaaS 产品不开放 API，或者 API 需要付费。
- **动态网页**：现代 SPA 应用的数据通过 JavaScript 动态加载，简单的爬虫无法获取。

### 4.6.1 UI 自动化的价值

| 场景 | 传统方案 | Agent 方案 |
|------|----------|------------|
| 批量填写表单 | 手动操作 | 自动识别并填写 |
| 跨系统数据同步 | 定制开发集成 | 通用 UI Agent |
| 网页信息采集 | 静态爬虫 | 动态渲染 + 智能提取 |

### 4.6.2 浏览器自动化技术栈

### 4.6.3 Playwright：现代浏览器控制

[Playwright](https://playwright.dev/) 是微软开源的浏览器自动化框架，支持 Chromium、Firefox 和 WebKit。

**核心能力**：
- **页面导航**：访问 URL、前进后退
- **元素交互**：点击、填写、拖拽
- **状态获取**：截图、读取文本、下载文件
- **网络拦截**：修改请求/响应

```python
from playwright.async_api import async_playwright

class BrowserAgent:
    def __init__(self):
        self.browser = None
        self.page = None
    
    async def start(self, headless: bool = True):
        playwright = await async_playwright().start()
        self.browser = await playwright.chromium.launch(headless=headless)
        self.page = await self.browser.new_page()
    
    async def navigate(self, url: str) -> str:
        """导航到指定 URL 并返回页面标题"""
        await self.page.goto(url, wait_until="networkidle")
        return await self.page.title()
    
    async def click(self, selector: str):
        """点击元素"""
        await self.page.click(selector)
        await self.page.wait_for_load_state("networkidle")
    
    async def fill_form(self, selector: str, text: str):
        """填写表单字段"""
        await self.page.fill(selector, text)
    
    async def get_text(self, selector: str) -> str:
        """获取元素文本内容"""
        element = await self.page.query_selector(selector)
        return await element.text_content() if element else ""
    
    async def screenshot(self) -> bytes:
        """获取当前页面截图"""
        return await self.page.screenshot(full_page=True)
    
    async def close(self):
        await self.browser.close()
```

### 4.6.4 将浏览器封装为 LLM 工具

将浏览器操作注册为 Agent 可调用的工具：

```python
browser_tools = [
    {
        "name": "navigate",
        "description": "导航到指定 URL",
        "parameters": {"url": "目标网址"}
    },
    {
        "name": "click",
        "description": "点击页面上的元素",
        "parameters": {"selector": "CSS 选择器或可见文本"}
    },
    {
        "name": "fill",
        "description": "在输入框中填写文本",
        "parameters": {"selector": "输入框选择器", "text": "要填写的内容"}
    },
    {
        "name": "screenshot",
        "description": "获取当前页面截图用于分析",
        "parameters": {}
    }
]
```

### 4.6.5 Computer Use：桌面级控制

### 4.6.6 Anthropic Computer Use

2024 年，Anthropic 推出了革命性的 **Computer Use** 功能，让 Claude 能够直接操控用户的桌面环境。

**工作原理**：

```
┌─────────────────────────────────────────────┐
│                 Claude 模型                  │
│  输入：屏幕截图 (Screenshot)                 │
│  输出：操作指令 (mouse_move, click, type)   │
└─────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────┐
│           Computer Use 执行层               │
│   - 截取屏幕                                 │
│   - 移动鼠标到坐标 (x, y)                    │
│   - 执行点击                                 │
│   - 模拟键盘输入                             │
└─────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────┐
│               用户桌面                       │
│   (任意应用程序：浏览器、Office、终端等)     │
└─────────────────────────────────────────────┘
```

#### 使用示例

```python
import anthropic
import base64

client = anthropic.Anthropic()

def computer_use_agent(task: str):
    messages = [{"role": "user", "content": task}]
    
    while True:
        response = client.beta.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=4096,
            tools=[
                {
                    "type": "computer_20241022",
                    "name": "computer",
                    "display_width_px": 1920,
                    "display_height_px": 1080,
                },
                {
                    "type": "bash_20241022",
                    "name": "bash",
                }
            ],
            messages=messages
        )
        
        # 处理工具调用
        for block in response.content:
            if block.type == "tool_use":
                if block.name == "computer":
                    # 执行鼠标/键盘操作
                    result = execute_computer_action(block.input)
                elif block.name == "bash":
                    # 执行命令行
                    result = execute_bash(block.input["command"])
                
                # 将结果（如新截图）反馈给模型
                messages.append({"role": "user", "content": result})
        
        if response.stop_reason == "end_turn":
            break
    
    return response
```

### 4.6.7 与传统自动化的区别

| 维度 | 传统自动化 (Selenium/Playwright) | Computer Use |
|------|----------------------------------|--------------|
| 定位方式 | CSS/XPath 选择器 | 视觉识别 |
| 适用范围 | 仅浏览器 | 任意桌面应用 |
| 脆弱性 | 选择器变化即失效 | 视觉稳定 |
| 开发成本 | 需要分析页面结构 | 自然语言描述即可 |

### 4.6.8 安全与风险控制

### 4.6.9 主要风险

1. **越权操作**：Agent 可能访问敏感系统或执行危险命令。
2. **数据泄露**：屏幕截图可能包含密码、个人信息。
3. **不可逆操作**：删除文件、发送邮件等无法撤销。

#### 安全最佳实践

```python
class SecureComputerAgent:
    BLOCKED_COMMANDS = ["rm -rf", "format", "del /f"]
    ALLOWED_DOMAINS = ["example.com", "internal.company.com"]
    
    def __init__(self):
        self.action_log = []
        self.require_approval = True
    
    def execute(self, action: dict) -> dict:
        # 1. 记录所有操作
        self.action_log.append({
            "action": action,
            "timestamp": datetime.now()
        })
        
        # 2. 检查危险操作
        if self._is_dangerous(action):
            if self.require_approval:
                return {"status": "pending_approval", "action": action}
            else:
                return {"status": "blocked", "reason": "危险操作被拦截"}
        
        # 3. 在沙箱中执行
        return self._execute_in_sandbox(action)
    
    def _is_dangerous(self, action: dict) -> bool:
        if action.get("type") == "bash":
            cmd = action.get("command", "")
            return any(blocked in cmd for blocked in self.BLOCKED_COMMANDS)
        return False
```

**核心原则**：
1. **沙箱隔离**：在虚拟机或 Docker 容器中运行。
2. **操作审批**：高风险操作需人工确认。
3. **完整日志**：记录所有操作用于审计和回溯。
4. **最小权限**：只授予完成任务所需的最小权限。

### 4.6.10 小结

浏览器自动化和 Computer Use 极大地扩展了 Agent 的行动边界：

- **Playwright/Selenium**：适用于 Web 任务自动化，需要了解页面结构。
- **Computer Use**：通用的桌面控制能力，基于视觉理解，无需了解底层实现。
- **安全第一**：这类能力风险极高，必须有完善的安全措施和人工监督机制。

这些技术让 "AI 员工" 从概念走向现实——它们可以像人类一样使用任何软件系统。

---

**下一节**: [本章小结](summary.md)