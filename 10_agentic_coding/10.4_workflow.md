# 10.4 智能体开发工作流

本节探讨如何将智能体编程融入日常开发工作流，实现从"写代码"到"编排 AI"的角色转变。

## 10.4.1 开发者角色的转变

### 从"写代码"到"编排 AI"

```
传统技能栈                           智能体时代技能栈
├── 语法精通                  ──→    ├── 系统设计思维
├── 算法背诵                  ──→    ├── 需求拆解能力
├── 调试技巧                  ──→    ├── 问题定义能力
├── 框架熟练                  ──→    ├── AI 工具链整合
├── 手速快                    ──→    ├── 验收与质量把控
│                                    ├── 上下文工程
│                                    └── 安全审计意识
```

### 新工作流概览

```python
class AgenticDeveloper:
    """智能体时代的开发者工作流"""
    
    def develop_feature(self, requirement: str):
        # 1. 理解并拆解需求
        tasks = self.decompose_requirement(requirement)
        
        # 2. 准备上下文
        context = self.prepare_context(
            relevant_files=self.find_related_code(tasks),
            documentation=self.fetch_docs(tasks),
            examples=self.find_similar_implementations(tasks)
        )
        
        # 3. 委托 AI 智能体执行
        for task in tasks:
            result = self.ai_agent.execute(
                task=task,
                context=context,
                constraints=self.get_constraints()  # 代码规范、安全要求等
            )
            
            # 4. 验收审查
            if not self.review(result):
                self.ai_agent.revise(result, self.feedback)
        
        # 5. 集成测试
        self.run_integration_tests()
        
        # 6. 文档更新
        self.ai_agent.update_documentation()
```

### 时间分配变化

| 活动 | 传统开发 | 智能体开发 |
|------|---------|-----------|
| 需求理解 | 20% | 30% |
| 编写代码 | 50% | 10% |
| 调试测试 | 20% | 15% |
| 审查验收 | 10% | 35% |
| 文档 | 少量 | AI 生成 |

## 10.4.2 任务分解方法论

### DECOMPOSE 框架

```
D - Define     定义：明确任务目标和边界
E - Explore    探索：了解现有代码和约束
C - Chunk      切分：将大任务分解为小任务
O - Order      排序：确定执行顺序和依赖
M - Map        映射：为每个任务分配工具/智能体
P - Prompt     提示：为每个任务设计清晰的提示词
O - Observe    观察：监控执行过程
S - Synthesize 综合：整合结果并验证
E - Evolve     进化：总结经验更新规则
```

### 任务分解示例

**原始需求**："实现一个用户认证模块"

```
任务分解：
│
├── 1. 需求理解
│   ├── 确认认证方式（JWT/OAuth/Session）
│   ├── 确认用户模型结构
│   └── 确认安全要求（2FA、密码策略）
│
├── 2. 技术调研
│   ├── 查看现有代码结构 @src/
│   ├── 确认框架版本和兼容性
│   └── 选择依赖库
│
├── 3. 实现阶段（可并行）
│   ├── 3.1 用户模型 → 智能体 A
│   ├── 3.2 认证逻辑 → 智能体 B
│   ├── 3.3 API 路由 → 智能体 A（依赖 3.1）
│   └── 3.4 前端集成 → 智能体 C
│
├── 4. 测试阶段
│   ├── 单元测试
│   ├── 集成测试
│   └── 安全测试
│
└── 5. 文档和部署
    ├── API 文档
    ├── 部署配置
    └── 变更日志
```

## 10.4.3 Cursor 智能体进阶实践

根据 Cursor 团队的官方最佳实践，以下技术能显著提升智能体的工作效率。

### 规划模式：规划先于执行

在 Cursor 中按 `Shift+Tab` 可激活 **规划模式**。进入该模式后，智能体不会立即编写代码，而是：

1. **调研代码库**：搜索相关文件，理解现有结构
2. **提出澄清问题**：确认需求边界和约束条件
3. **创建实施计划**：生成可编辑的 Markdown 计划文档
4. **等待批准**：用户确认后才开始实现

```
┌─────────────────────────────────────────────────────────────────┐
│                   规划模式工作流                                 │
├─────────────────────────────────────────────────────────────────┤
│  用户请求 → 代码库调研 → 澄清提问 → 生成计划                      │
│                                    ↓                            │
│  用户审核 ← 修改计划 ← 计划文档 (.cursor/plans/)                  │
│                                    ↓                            │
│                           批准后开始实现                          │
└─────────────────────────────────────────────────────────────────┘
```

### 回退优于修补

> [!TIP]
> **智能体编程黄金法则**：如果智能体的实现偏离了轨道，**不要试图通过后续对话来"修补"它**——这通常会导致代码越来越乱。
> 
> **正确的做法是**：
> 1. 如果你在 Git 环境中，`git reset --hard` 或 `git stash` 回滚更改
> 2. 如果使用 Cursor 规划模式，点击"Previous Plan"或修改现有计划
> 3. 澄清需求，细化步骤，重新运行
> 
> **记住：一次正确的全新生成，永远优于十次修补。**

### 上下文管理策略

#### 让智能体自己找上下文

不需要手动标记每个文件。现代智能体有强大的搜索工具，按需拉取上下文：

```markdown
不好的做法：
"请看 @src/api/users.py @src/models/user.py @src/services/user_service.py 
 @src/repositories/user_repo.py @tests/test_users.py 帮我修改用户验证逻辑"

好的做法：
"帮我修改用户验证逻辑，登录时需要检查用户是否被禁用"
（让智能体自己搜索相关文件）
```

#### 何时开启新对话 vs 继续对话

| 开启新对话 | 继续对话 |
|-----------|---------|
| 切换到不同任务或功能 | 迭代同一功能 |
| 智能体看起来困惑或重复犯错 | 智能体需要早期对话的上下文 |
| 完成一个逻辑工作单元 | 调试它刚构建的东西 |
| 对话超过 20 轮 | 对话仍然聚焦 |

> **长对话会导致智能体失去焦点**。经过多轮对话和摘要后，上下文积累噪声，智能体可能分心或切换到无关任务。

#### 引用过去的工作

开始新对话时，使用 `@Past Chats` 引用之前的工作，而不是复制粘贴整个对话：

```markdown
"继续上次 @Past Chats 关于认证模块的工作，现在需要添加 2FA 支持"
```

### 并行智能体与 Git 工作树

Cursor 原生支持 Git 工作树，可让多个智能体同时工作而互不干扰：

```
主分支 ─────────────────────────────────────────→
         │ worktree-1              │ worktree-2
         │ 智能体 A: 实现功能 X     │ 智能体 B: 重构模块 Y
         │                         │
         └─────── 合并 ────────────┴────→ 主分支
```

**创建并行工作环境**：

```bash
# 创建工作树
git worktree add ../project-feature-auth -b feature/auth
git worktree add ../project-refactor-api -b refactor/api

# 在不同 Cursor 窗口打开
cursor ../project-feature-auth
cursor ../project-refactor-api

# 两个智能体同时工作
# 完成后合并
git merge feature/auth
git merge refactor/api
```

## 10.4.4 测试驱动开发 (TDD) 与智能体

智能体在有明确目标可迭代时表现最佳。测试允许智能体做出更改、评估结果、逐步改进直到成功。

### TDD 工作流

```
┌─────────────────────────────────────────────────────────────────┐
│                    TDD + 智能体工作流                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐                                                   │
│  │ 1. 定义  │ 让智能体根据预期输入/输出编写测试                     │
│  └────┬─────┘                                                   │
│       │                                                         │
│       ▼                                                         │
│  ┌──────────┐                                                   │
│  │ 2. 验证  │ 告诉智能体运行测试并确认失败                         │
│  │    失败  │ （不要写实现！）                                    │
│  └────┬─────┘                                                   │
│       │                                                         │
│       ▼                                                         │
│  ┌──────────┐                                                   │
│  │ 3. 提交  │ 满意后提交测试                                      │
│  │    测试  │                                                   │
│  └────┬─────┘                                                   │
│       │                                                         │
│       ▼                                                         │
│  ┌──────────┐                                                   │
│  │ 4. 实现  │ 让智能体编写通过测试的代码                           │
│  │    功能  │ （不要修改测试！）                                   │
│  └────┬─────┘                                                   │
│       │                                                         │
│       ▼                                                         │
│  ┌──────────┐                                                   │
│  │ 5. 提交  │ 满意后提交实现                                      │
│  │    实现  │                                                   │
│  └──────────┘                                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### TDD 提示词示例

```markdown
第一步（定义测试）：
"为 LRU 缓存类编写测试，测试以下场景：
 - 基本 get/put 操作
 - 容量超限时淘汰最久未使用的项
 - 并发安全
 不要实现功能，只写测试。"

第二步（验证失败）：
"运行测试确认它们失败（因为还没有实现）"

第三步（实现）：
"现在实现 LRU 缓存类让所有测试通过，不要修改测试文件"
```

## 10.4.5 架构可视化优先

在编写任何复杂功能之前，先让智能体画图。

### 为什么先画图？

1. **验证理解**：确认智能体脑子里的架构和你想要的一致
2. **文档化**：生成的图表直接存入 `docs/architecture/`，成为永久文档
3. **发现缺陷**：在写代码之前，通过看图往往能一眼发现逻辑漏洞

### 架构图提示词示例

```markdown
"为认证系统创建一个 Mermaid 序列图，包括：
 - OAuth 提供商交互
 - 会话管理
 - Token 刷新流程
 - 错误处理分支"
```

**智能体输出**：

```mermaid
sequenceDiagram
    participant U as User
    participant C as Client
    participant A as Auth Server
    participant O as OAuth Provider
    
    U->>C: 点击"Google 登录"
    C->>O: 重定向到 OAuth
    O->>U: 显示授权页面
    U->>O: 授权
    O->>C: 返回 authorization code
    C->>A: 发送 code
    A->>O: 交换 access token
    O-->>A: 返回 token
    A->>A: 创建用户会话
    A-->>C: 返回 JWT
    C->>C: 存储 JWT
    
    Note over C,A: Token 刷新流程
    C->>A: 发送 refresh token
    A->>A: 验证并生成新 token
    A-->>C: 返回新 JWT
```

## 10.4.6 代码审查工作流

### AI 生成代码的审查清单

```markdown
## 功能正确性
- [ ] 代码实现了预期功能
- [ ] 边界情况被正确处理
- [ ] 错误处理完善

## 代码质量
- [ ] 遵循项目代码规范
- [ ] 无明显的性能问题
- [ ] 无重复代码
- [ ] 命名清晰合理

## 安全性
- [ ] 无硬编码的密钥/密码
- [ ] 输入已正确验证
- [ ] 无 SQL 注入风险
- [ ] 无 XSS 风险

## 可维护性
- [ ] 有必要的注释
- [ ] 逻辑清晰易懂
- [ ] 依赖合理

## 测试
- [ ] 有对应的测试用例
- [ ] 测试覆盖关键路径
- [ ] 测试可以通过
```

### 让智能体自审

```markdown
"审查你刚才生成的代码，检查：
 1. 是否有安全漏洞
 2. 是否遵循了项目的代码规范
 3. 是否有性能问题
 4. 是否需要添加更多测试"
```

## 10.4.7 调试模式

当标准智能体交互难以解决 bug 时，Debug Mode 提供不同的方法：

```
Debug Mode 工作流程：
1. 生成多个关于可能出错的假设
2. 用日志语句检测代码
3. 要求重现 bug 同时收集运行时数据
4. 分析实际行为以定位根因
5. 基于证据进行定向修复
```

**适用场景**：
- 可重现但无法弄清的 bug
- 竞态条件和时序问题
- 性能问题和内存泄漏
- 曾经正常的回归问题

**提示词示例**：

```markdown
"这个函数有时会返回 null，但我不知道什么条件下会发生。
 请帮我：
 1. 列出可能导致返回 null 的所有情况
 2. 添加日志语句来追踪执行路径
 3. 建议如何重现这个问题"
```

## 10.4.8 小结

| 工作流阶段 | 关键实践 |
|-----------|---------|
| 任务分解 | 使用 DECOMPOSE 框架 |
| 规划 | 规划模式先行，回退优于修补 |
| 上下文 | 让智能体自己找，适时开新对话 |
| 并行 | 利用 Git 工作树并行开发 |
| 测试 | TDD 工作流驱动智能体 |
| 架构 | 先画图再写码 |
| 审查 | 执行清单 + 让智能体自审 |
| 调试 | 假设驱动的 Debug Mode |

---

**下一节**: [最佳实践与复盘](10.5_best_practices.md)
