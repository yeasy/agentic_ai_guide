# 10.5 最佳实践与复盘

本节汇总智能体编程的最佳实践，帮助你避免常见陷阱并持续提升效率。

## 10.5.1 提示词最佳实践

### 提供充足上下文

```markdown
❌ 不好的提示词：
"修复这个 bug"

✅ 好的提示词：
"@src/api/users.py 的 get_user 函数在用户 ID 为空时抛出 500 错误。
预期行为：返回 400 Bad Request 并给出清晰的错误信息。
参考 @src/api/orders.py 中类似的错误处理模式。"
```

### CLEAR 提示词框架

```
C - Context    上下文：提供相关背景信息
L - Location   位置：指明具体的文件和位置
E - Expected   预期：描述期望的行为或结果
A - Actual     实际：描述当前的问题或行为
R - Reference  参考：提供相关的参考实现
```

**示例应用**：

```markdown
C：我们的 API 使用 FastAPI，认证采用 JWT
L：@src/api/auth.py 的 verify_token 函数
E：Token 过期时应返回 401 并提示刷新
A：目前返回 500 错误，没有有意义的错误信息
R：参考 @src/api/middleware.py 中的错误处理模式
```

### 分步骤执行复杂任务

```markdown
❌ 不好的做法：
"帮我从头开始写一个完整的电商后端"

✅ 好的做法：
1. "先设计数据库 Schema，参考 @docs/requirements.md"
2. "基于 Schema 生成 SQLAlchemy 模型"
3. "实现用户认证模块，使用 JWT"
4. "实现商品 CRUD API"
5. "实现订单处理逻辑"
6. "编写集成测试"
```

### 验证和测试一起请求

```markdown
"实现一个 LRU 缓存类，要求：
1. 支持 get 和 put 操作
2. 容量超限时淘汰最久未使用的项
3. 时间复杂度 O(1)

同时编写完整的单元测试覆盖：
- 基本功能测试
- 边界情况测试
- 并发安全测试"
```

## 10.5.2 保持人类监督

```
智能体编程黄金法则：
├── ✅ AI 生成，人类审查
├── ✅ AI 提案，人类决策
├── ✅ AI 执行，人类验收
├── ❌ 完全自动化关键系统
└── ❌ 跳过代码审查直接部署
```

### 监督强度分级

| 任务类型 | 风险级别 | 监督要求 |
|---------|---------|---------|
| 格式化、重命名 | 低 | 自动执行，事后检查 |
| 新功能开发 | 中 | 逐步执行，每步确认 |
| 重构核心模块 | 高 | 规划先行，详细审查 |
| 安全相关修改 | 极高 | 专家审查，多人确认 |
| 生产环境操作 | 极高 | 人工执行，智能体仅建议 |

### 建立检查点

```markdown
复杂任务执行模式：

任务开始
    │
    ▼
[阶段 1] 智能体调研
    │
    ▼
[检查点 1] 人类确认理解正确
    │
    ▼
[阶段 2] 智能体生成计划
    │
    ▼
[检查点 2] 人类审核并修改计划
    │
    ▼
[阶段 3] 智能体执行第一步
    │
    ▼
[检查点 3] 人类验证结果
    │
    ▼
... 继续 ...
```

## 10.5.3 Claude 技能系统

**技能（Skills）** 是 Claude Code 的核心扩展机制，允许将团队的过程性知识封装为可复用的知识包。

### 什么是技能

如果说 MCP 赋予 Claude 访问外部系统的能力（"手"），那么技能则赋予 Claude 专业领域知识（"脑"）。

> **核心比喻**：  
> MCP = 硬件商店的货架（提供工具）  
> Skills = 熟练店员的专业知识（教你如何使用）

### 技能结构

```
skill-folder/
├── SKILL.md              # YAML 元数据 + 核心指令
├── references/           # 按需加载的详细文档
│   ├── finance.md       # 财务指标定义
│   └── product.md       # 产品数据 Schema
└── scripts/              # 辅助脚本（可选）
    ├── validate.py      # 验证脚本
    └── format.py        # 格式化脚本
```

### SKILL.md 编写规范

```markdown
---
name: sql-analysis
description: |
  Use when analyzing business data: revenue, ARR, customer 
  segments, product usage. Provides table schemas, metric 
  definitions, required filters, and query patterns.
---

# SQL Analysis Skill

## 快速开始工作流
1. **Clarify the request** - 时间范围？客户分群？
2. **Check for existing dashboards** - 查看 references/dashboards.md
3. **Identify the data source** - 优先使用聚合表
4. **Execute the analysis** - 应用必需过滤器

## 标准查询过滤器
- Always exclude test accounts: `WHERE account != 'Test'`
- Always use complete periods only
- Always apply tenant isolation: `WHERE tenant_id = ?`

## 知识库
详细 Schema 见：
- **Revenue & Finance** → `references/finance.md`
- **Product Usage** → `references/product.md`
- **Customer Data** → `references/customer.md`

## 常见错误模式
❌ 不要直接查询 events 表（太大）
✅ 使用 events_daily_agg 聚合表

❌ 不要跨月聚合未完成的月份
✅ 使用 completed_periods 视图
```

### 技能的加载时机

| 类型 | 加载时机 | 示例 |
|------|---------|------|
| Rules | 始终加载 | 项目代码规范 |
| Skills | 按需加载 | SQL 分析、代码审查 |
| References | 技能内按需 | 详细 Schema 定义 |

## 10.5.4 钩子系统

**钩子（Hooks）** 是 Claude Code 的生命周期钩子，允许在特定事件发生时自动执行自定义脚本。

### 8 种生命周期事件

| 钩子 | 触发时机 | 典型用途 |
|------|---------|---------| 
| **PreToolUse** | 工具执行前 | 拦截危险操作、修改参数 |
| **PostToolUse** | 工具执行后 | 自动格式化、审计日志 |
| **PermissionRequest** | 权限请求前 | 自动批准安全命令 |
| **SessionStart** | 会话开始 | 注入项目上下文 |
| **SessionEnd** | 会话结束 | 清理临时文件 |
| **TaskStart** | 任务开始 | 记录任务日志 |
| **TaskEnd** | 任务结束 | 保存执行轨迹 |
| **Error** | 发生错误时 | 错误上报和恢复 |

### 钩子实现示例

```typescript
// .claude/hooks/pre-tool-use.ts
export default async function(context: HookContext) {
  const { tool, params } = context;
  
  // 拦截危险的文件删除
  if (tool === 'file_delete') {
    if (params.path.includes('production')) {
      return {
        block: true,
        message: '禁止删除生产环境文件'
      };
    }
  }
  
  // 审计所有命令执行
  if (tool === 'run_command') {
    await context.log({
      event: 'command_execution',
      command: params.command,
      user: context.user,
      timestamp: new Date()
    });
  }
  
  return { block: false };
}
```

### 高级模式：长运行智能体循环

通过钩子配合技能，可以创建能自主迭代直到成功的"长运行智能体"：

```typescript
// .claude/hooks/grind.ts
// 让智能体"一直改代码直到测试通过"

export default async function(context: HookContext) {
  const MAX_ITERATIONS = 10;
  
  if (context.loopCount < MAX_ITERATIONS) {
    const result = await context.runTests();
    
    if (!result.passed) {
      // 拦截停止信号，返回新的用户消息
      return {
        continue: true,
        message: `测试未通过 (${result.failed}/${result.total})。
错误信息：
${result.errors}

请修复代码并重试。这是第 ${context.loopCount + 1} 次尝试。`
      };
    }
  }
  
  return { continue: false };
}
```

这种模式将"编写-测试-修复"的循环完全自动化，是智能体编程的终极形态之一。

## 10.5.5 复利工程

传统的 AI 编程是线性的（Prompt → Code），而 **复利工程（Compounding Engineering）** 致力于构建具有记忆的系统。

### 核心循环

```
┌─────────────────────────────────────────────────────────────────┐
│                      复利工程循环                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│     ┌──────────┐                                                │
│     │ 1. Issue │ 遇到 Bug 或 Bad Case                           │
│     └────┬─────┘                                                │
│          │                                                       │
│          ▼                                                       │
│     ┌──────────┐                                                │
│     │ 2. Fix   │ 修复代码                                        │
│     └────┬─────┘                                                │
│          │                                                       │
│          ▼                                                       │
│     ┌──────────┐                                                │
│     │ 3. Learn │ 问自己"如何防止下次再犯？"                       │
│     └────┬─────┘                                                │
│          │                                                       │
│          ├──→ 更新 AGENTS.md（项目知识库）                        │
│          ├──→ 添加 Linter 规则                                   │
│          ├──→ 更新系统提示词                                      │
│          └──→ 创建新的 Skill                                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 知识沉淀形式

| 形式 | 位置 | 作用 |
|------|------|------|
| AGENTS.md | 项目根目录 | 项目级知识 |
| Rules | `.cursor/rules/` | 行为规则 |
| Skills | 技能目录 | 领域知识 |
| Linter 规则 | ESLint/Pylint 配置 | 自动检查 |
| 测试用例 | tests/ | 回归防护 |

### 复利效应

```
第 1 个月：项目有 10 条规则
第 2 个月：+15 条规则（来自 bug 修复）
第 3 个月：+20 条规则 + 3 个技能
...
第 12 个月：200+ 条规则 + 15 个技能

结果：
- 智能体错误率下降 80%
- 新人入职时间缩短 60%
- 代码一致性显著提升
```

通过这种方式，智能体的每一次错误都成为系统进化的养料。这是通用模型无法比拟的护城河。

## 10.5.6 刻意练习

为什么有些开发者觉得 AI 没用？因为他们没有进行**刻意练习**。

### 练习方法

| 练习方式 | 目的 | 实践建议 |
|---------|------|---------|
| **把 AI 当乐器** | 熟悉"手感" | 每天使用，观察模式 |
| **干净环境实验** | 测试极限 | 在 Side Project 中试验 |
| **刻意犯错** | 理解边界 | 故意给出模糊指令，观察反应 |
| **对比测试** | 发现差异 | 同任务用不同模型/提示词 |
| **复盘分析** | 积累经验 | 记录成功/失败的模式 |

### 建立肌肉记忆

```
遇到问题 X ──→ 启动 Y 类型对话

示例：
- 遇到 Bug → Debug Mode + 假设列表
- 新功能 → 规划模式 + TDD
- 重构 → 先画架构图 + 分步执行
- 性能问题 → 让智能体分析并建议
- 文档 → 让智能体基于代码生成
```

### 学习路径

```
初级（1-2 周）
├── 熟悉基本对话
├── 掌握 @ 引用
└── 理解上下文管理

中级（1-2 月）
├── 掌握规划模式
├── 配置 Rules 和 Skills
├── 建立复利工程习惯
└── 多工具组合使用

高级（3+ 月）
├── 设计自定义工作流
├── 钩子系统定制
├── 并行智能体编排
└── 团队知识库建设
```

## 10.5.7 企业级实践数据

根据 2026 年 Anthropic 企业调研，智能体编程已成为企业主流：

### 采用情况

| 指标 | 数据 |
|------|------|
| 企业使用率 | 90% 的企业使用 AI 辅助开发 |
| 效率提升 | 代码生成和文档编写平均节省约 60% 时间 |
| ROI | 平均投资回报期 < 6 个月 |

### 典型案例

| 公司 | 场景 | 效果 |
|------|------|------|
| Thomson Reuters | 文档搜索 | 从数小时降至分钟级 |
| Dropbox | 代码审查 | 审查周期缩短 40% |
| Stripe | API 文档生成 | 文档覆盖率提升 3 倍 |

### 关键成功因素

1. **开发周期加速**：消除认知开销，自动追踪依赖关系
2. **入职时间降低**：智能体作为"有完美记忆的搭档"
3. **技术能力民主化**：前端可优化 SQL，后端可改进 UI
4. **知识传承**：隐性知识显性化为规则和技能

### 常见失败模式

| 失败模式 | 原因 | 解决方案 |
|---------|------|---------|
| "AI 没用" | 缺乏刻意练习 | 投入时间学习工具 |
| 质量下降 | 跳过审查 | 建立审查流程 |
| 知识流失 | 不做沉淀 | 实践复利工程 |
| 安全事故 | 权限过大 | 实施最小权限 |

## 10.5.8 安全边界

### 永远不要让智能体做的事情

```
禁止清单：
├── 直接操作生产数据库
├── 执行未审查的 shell 命令
├── 修改安全相关配置
├── 处理未脱敏的敏感数据
├── 自动部署到生产环境
└── 访问密钥管理系统
```

### 安全护栏配置

```markdown
# .cursor/rules/security.md

## 禁止操作
- 不要读取或修改 .env 文件
- 不要执行 `rm -rf` 相关命令
- 不要直接操作 production 分支
- 不要输出任何密钥或密码

## 敏感文件保护
以下文件只读，不可修改：
- config/production.yml
- secrets/
- .github/workflows/deploy.yml

## 命令限制
以下命令需要人工确认：
- docker push
- kubectl apply
- npm publish
```

## 10.5.9 小结

| 最佳实践 | 关键要点 |
|---------|---------|
| **提示词** | CLEAR 框架，分步执行，同时请求测试 |
| **监督** | 分级监督，建立检查点 |
| **技能系统** | 封装领域知识，按需加载 |
| **钩子系统** | 生命周期自动化，长运行智能体 |
| **复利工程** | 每次错误都是进化机会 |
| **刻意练习** | 建立肌肉记忆，持续提升 |
| **安全边界** | 最小权限，禁止清单 |

---

**下一章**: [第十一章：安全、伦理与未来](../11_future/README.md)
