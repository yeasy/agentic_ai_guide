# 10.2 智能体编程原理

要真正掌握 Agentic Coding，我们必须打开 AI 的"黑盒"，看看它是如何工作的。本节深入解析智能体的核心工作机制，帮助你从原理层面理解智能体编程。

## 10.2.1 核心循环：Agent Loop

智能体并不是一次性生成完整代码的神谕，而是一个**状态机**。它的工作流程是一个被"展开"的循环：

```mermaid
sequenceDiagram
    participant U as User
    participant M as Model
    participant E as Environment (Files/Term)
    
    U->>M: "帮我把 API 从 Flask 迁移到 FastAPI"
    note right of U: State 0
    
    loop The Agent Loop
        M->>M: 思考 (思维链)
        M->>E: 工具调用: list_files()
        E-->>M: 返回: [app.py, requirements.txt...]
        note right of M: State 1 (上下文变长)
        
        M->>M: 思考: "需要先读取 app.py"
        M->>E: 工具调用: read_file(app.py)
        E-->>M: 返回: "from flask import..."
        note right of M: State 2 (上下文更长)
        
        M->>E: 工具调用: write_file(app.py)
        note left of E: 写入磁盘
        E-->>M: 返回: "Success"
    end
    
    M->>U: "迁移完成，请运行测试。"
```

### Agent Loop 的三个阶段

每次循环都包含以下三个阶段：

```
┌─────────────────────────────────────────────────────────────────┐
│                      Agent Loop 单次迭代                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                  │
│  │ 1. 思考   │ ──→ │ 2. 行动   │ ──→ │ 3. 观察   │                  │
│  │ (Think)  │    │ (Act)    │    │ (Observe) │                  │
│  └──────────┘    └──────────┘    └──────────┘                  │
│       │              │               │                          │
│       ▼              ▼               ▼                          │
│  分析当前状态    调用工具执行     处理工具返回                      │
│  规划下一步      文件/命令/API    更新内部状态                      │
│  生成推理链      读写/搜索等      决定是否继续                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 循环何时终止？

Agent Loop 在以下情况下终止：

1. **任务完成**：智能体判断目标已达成
2. **达到最大迭代次数**：防止无限循环
3. **遇到错误**：无法恢复的错误导致终止
4. **用户中断**：用户手动停止执行
5. **Token 预算耗尽**：上下文窗口接近限制

## 10.2.2 停止序列的魔法

模型本质上是一个"文本补全机"。如果没有约束，它会在生成 `tool_call()` 后继续幻想出工具的返回结果。

智能体工作的关键在于 **停止序列（Stop Sequence）**。

### 工作原理

```mermaid
sequenceDiagram
    participant H as Host (Python/Rust)
    participant M as Model
    participant T as Tool Executor
    
    H->>M: 发送完整上下文
    M->>M: 生成 "我需要查看文件..."
    M->>M: 生成 "<tool_call>read_file('app.py')"
    M->>M: 遇到停止序列 "</tool_call>"
    M-->>H: 返回生成内容 + 停止原因
    
    Note over H: 解析工具调用
    H->>T: 执行 read_file('app.py')
    T-->>H: 返回文件内容
    
    H->>M: 原上下文 + 工具结果
    M->>M: 继续推理...
```

### 关键机制

*   当模型生成特定的停止符（如 `\nObservation:` 或 `</tool_call>`）时，推理**强制暂停**
*   控制权交还给 Python/Rust 宿主程序
*   宿主程序执行真正的 Shell 命令或文件读写
*   宿主将结果拼接到上下文后面，**再次调用模型**

这就是为什么有时候你会感觉到智能体"卡顿"了一下——那正是它停止生成、等待工具执行完并返回结果的时刻。

### 不同框架的停止序列设计

| 框架/平台 | 停止序列格式 | 工具调用格式 |
|----------|------------|-------------|
| OpenAI | 内置 function calling | JSON Schema |
| Anthropic | `</tool_use>` | XML-like |
| LangChain/ReAct | `\nObservation:` | 自然语言 + JSON |
| Cursor | 内部协议 | 专有格式 |

## 10.2.3 不可见的状态

在 Chat 界面上，你只看到了"你好"和"结果"。但在冰山之下，上下文窗口里堆积了成千上万行你没看见的内容：

### 冰山图

```
                    ┌─────────────────────┐
                    │    用户看到的        │
                    │  "帮我优化性能"      │    ← 显示层
                    │  "已优化完成"        │
                    ├─────────────────────┤ ─ ─ ─ 水面 ─ ─ ─
                    │                     │
                    │  LSP 诊断信息        │    Linter 报错 x5
                    │  文件树快照          │    目录结构
                    │  搜索结果            │    grep 匹配 x23
                    │  读取的文件内容       │    3 个文件共 2000 行
                    │  尝试失败的历史       │    3 次修改失败
                    │  自我修正对话        │    内部推理链
                    │  系统提示词          │    ~2000 tokens
                    │                     │    ← 不可见层
                    └─────────────────────┘
```

### 隐藏状态的类型

1. **LSP 诊断信息**：你没运行代码，但智能体已在后台运行了 Linter 并看到了报错
2. **文件树快照**：智能体默默看了一眼目录结构
3. **搜索结果**：智能体执行了多次代码搜索
4. **自我修正历史**：智能体可能尝试了 3 次修改失败，第 4 次才成功，但只展示了最后的结果
5. **系统提示词**：框架注入的规则和约束

### 为什么这很重要？

理解这一点，你就会明白：

> **当智能体表现不佳时，往往不是它"笨"，而是不可见的状态（上下文）被污染了。**

**常见污染场景**：
- 早期对话中的错误假设被保留
- 无关文件的内容占用了上下文空间
- 失败尝试的堆积导致智能体"困惑"

**解决方案**：
- 重置对话（New Chat）——清空不可见噪音的最有效手段
- 使用 @ 引用精确控制上下文
- 定期检查智能体"看到了什么"

## 10.2.4 Agent Harness：驾驭模型的缰绳

根据 Cursor 团队的定义，一个完整的 **Agent Harness**（智能体驾驭系统）由三个核心组件构成：

```
┌─────────────────────────────────────────────────────────────────┐
│                        Agent Harness                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    1. 指令 (Instructions)                 │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │  │
│  │  │ 系统提示词   │  │   Rules     │  │   Skills    │       │  │
│  │  │ (System)    │  │  (.cursor/) │  │  (动态加载)  │       │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    2. 工具 (Tools)                        │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │  │
│  │  │  文件编辑    │  │  代码搜索   │  │  终端执行    │       │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘       │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │  │
│  │  │  浏览器     │  │   MCP 服务   │  │  自定义工具  │       │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                 3. 用户消息 (User Messages)               │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │  │
│  │  │  初始提示词  │  │  后续指令   │  │  @ 引用上下文 │       │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 三大组件详解

#### 1. 指令（Instructions）

控制智能体的行为和风格：

| 类型 | 位置 | 作用 | 加载时机 |
|------|------|------|---------|
| 系统提示词 | 框架内置 | 定义基本行为 | 始终加载 |
| Rules | `.cursor/rules/` | 项目特定约定 | 始终加载 |
| Skills | 技能目录 | 领域知识 | 按需加载 |
| AGENTS.md | 项目根目录 | 项目说明 | 始终加载 |

#### 2. 工具（Tools）

赋予智能体执行能力：

```python
# 典型工具集
tools = [
    "file_read",      # 读取文件
    "file_write",     # 写入文件
    "file_search",    # 语义搜索
    "grep_search",    # 正则搜索
    "run_command",    # 终端命令
    "browser_action", # 浏览器操作
    "mcp_tool",       # MCP 服务调用
]
```

#### 3. 用户消息（User Messages）

驱动智能体行动的输入：

- **初始提示词**：描述任务目标
- **后续指令**：提供反馈和调整
- **@ 引用**：精确注入上下文

### 模型差异

不同的模型对同一套 Harness 的反应不同：

| 模型 | 指令遵循 | 工具使用 | 长期任务 |
|------|---------|---------|---------|
| Claude 3.5 Sonnet | 优秀 | 优秀 | 良好 |
| GPT-4o | 良好 | 优秀 | 良好 |
| Claude 3 Opus | 优秀 | 良好 | 优秀 |
| GPT-5.2 | 优秀 | 优秀 | 优秀 |

> [!TIP]
> 高效的 Agentic Coding 需要学会通过 Rules 和 Skills 来调整 Harness，以适配不同模型的特点。

## 10.2.5 上下文窗口管理

上下文窗口是智能体的"工作记忆"，管理不当会导致性能下降。

### 上下文组成

```
┌─────────────────────────────────────────────────────────────────┐
│                  上下文窗口 (128K tokens 示例)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────┐                             │
│  │ 系统提示词 + Rules              │  ~2K tokens (固定)         │
│  └────────────────────────────────┘                             │
│  ┌────────────────────────────────┐                             │
│  │ 用户任务描述                    │  ~500 tokens              │
│  └────────────────────────────────┘                             │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                                                             │ │
│  │ 工具调用历史 + 结果                                          │ │
│  │ (文件内容、搜索结果、命令输出)                                │ │
│  │                                                             │ │
│  │                    动态增长区域                               │ │
│  │                  (~20K-100K tokens)                         │ │
│  │                                                             │ │
│  └────────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────┐                             │
│  │ 预留给模型输出                  │  ~4K tokens (输出缓冲)     │
│  └────────────────────────────────┘                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 上下文管理策略

| 策略 | 描述 | 适用场景 |
|------|------|---------|
| **精确引用** | 只引入必要的文件和行 | 大型代码库 |
| **摘要压缩** | 对早期对话进行摘要 | 长对话 |
| **滑动窗口** | 保留最近 N 轮 | 实时交互 |
| **分层加载** | 先索引后详情 | 复杂任务 |

### 上下文污染的信号

当你观察到以下现象时，说明上下文可能已被污染：

- 智能体重复相同的错误
- 智能体提到了不相关的文件
- 智能体忘记了早期的约定
- 响应速度明显变慢

**解决方案**：开始新对话，重新描述任务。

## 10.2.6 调试智能体行为

当智能体表现异常时，如何定位问题？

### 调试清单

```
智能体调试流程：
│
├── 1. 检查输入
│   ├── 任务描述是否清晰？
│   ├── 是否提供了足够的上下文？
│   └── @ 引用是否正确？
│
├── 2. 检查配置
│   ├── Rules 是否正确加载？
│   ├── Skills 是否被识别？
│   └── 模型选择是否合适？
│
├── 3. 检查执行
│   ├── 工具调用是否成功？
│   ├── 是否有权限问题？
│   └── 是否达到迭代限制？
│
└── 4. 检查上下文
    ├── 上下文是否过长？
    ├── 是否有污染信息？
    └── 是否需要重置对话？
```

### 常见问题及解决方案

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| 智能体不调用工具 | 任务描述不明确 | 明确说"请修改文件" |
| 智能体修改错误文件 | 上下文中有多个相似文件 | 使用 @ 精确引用 |
| 智能体重复失败尝试 | 上下文污染 | 重置对话 |
| 智能体响应变慢 | 上下文过长 | 精简引用内容 |
| 智能体忽略 Rules | Rules 格式错误 | 检查 Markdown 格式 |

## 10.2.7 小结

| 概念 | 核心要点 |
|------|---------|
| **Agent Loop** | 思考→行动→观察的循环执行 |
| **停止序列** | 控制模型暂停、等待工具结果 |
| **不可见状态** | 上下文中大量用户看不到的信息 |
| **Agent Harness** | 指令+工具+消息的组合 |
| **上下文管理** | 智能体工作记忆的优化 |

**关键认知**：
1. 智能体不是魔法，是可解释的状态机
2. 上下文窗口是稀缺资源，需要精心管理
3. 当智能体"笨"的时候，先检查不可见状态
4. 重置对话是最简单有效的调试手段

---

**下一节**: [主流工具详解](10.3_tools.md)
