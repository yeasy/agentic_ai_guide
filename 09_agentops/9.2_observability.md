## 9.2 可观测性 与调试

在传统的软件开发中，我们有 Stack Trace 报错堆栈。但在智能体开发中，"Bug" 往往不是代码崩溃，而是智能体 "一本正经地胡说八道" 或者 "陷入了无意义的死循环"。

当智能体出错时，你不能只看最后一行输出。你需要像黑匣子一样，记录下它每一次思考、每一次工具调用和每一次状态更新。这就是智能体的 **可观测性（Observability）**。

#### 为什么智能体难以调试

1.  **非确定性 (Nondeterminism)**：同样的 Prompt，上午跑是通的，下午跑就挂了。
2.  **黑盒推理**：LLM 为什么决定调用 Search 而不是 Calculator？
3.  **多步级联**：第 5 步的错误可能是第 1 步的一个微小偏差导致的蝴蝶效应。
4.  **成本隐患**：一个死循环的智能体可能在一夜之间烧掉几千美元。

### 9.2.1 核心指标：Trace, Span 与 Run

借鉴 **分布式追踪 (Distributed Tracing)** 的概念，我们这样定义智能体的监控数据：

- **链路（Trace）**：代表一次完整的用户请求处理全过程（Request）。
- **运行/跨度（Run / Span）**：链路中的每一个原子操作。例如：
  - 一次 LLM 调用 (LLM Run)
  - 一次工具执行 (Tool Run)
  - 一次检索 (Retriever Run)
  - 一次子链执行 (Chain Run)

### 9.2.2 一个典型的 Trace 结构
```text
Trace ID: 890s-f9s8-s9d8
  ├── [Chain] Main Agent (Duration: 5s, Cost: $0.02)
  │    ├── [LLM] Planner: "我要先查天气..."
  │    ├── [Tool] Search("Beijing weather")
  │    │    └── [Output] "Sunny, 25C"
  │    ├── [LLM] Generator: "今天北京天气不错..."
  │    └── [Output] Final Answer
```

### 9.2.3 主流可观测性工具平台

#### LangSmith

目前体验最好的 AgentOps 平台。

- **核心功能**：
  - **Tracing**：可视化展示每一步的输入输出。
  - **Playground（演练场）**：在 Trace 界面直接点击 "Edit"，进入 Playground 修改 Prompt 并重跑这一步。这是调试 Prompt 最快的方法。
  - **Dataset**：将线上的 Trace 一键添加到测试数据集。
  
- **代码集成**：
  只要设置环境变量，LangChain 应用会自动上报数据。
  ```bash
  export LANGCHAIN_TRACING_V2=true
  export LANGCHAIN_API_KEY=ls-...
  ```

#### Arize Phoenix (开源)

如果是本地开发或对数据隐私敏感，Phoenix 是极佳的开源选择。

- **特点**：支持本地启动 Web UI，支持对 Embedding 检索质量的可视化分析。
- **适用**：RAG 应用的深度调试。

#### Weights & Biases

从传统的 ML 训练监控切入智能体监控。

- **特点**：强大的提示词注册表 (Prompts Registry)。适合需要多人协作调优 Prompt 的团队。

### 9.2.4 多智能体系统的失败诊断框架

当多智能体系统出现问题时，如何系统性地定位根因？研究论文《[Why Do Multi-Agent LLM Systems Fail?](https://arxiv.org/abs/2503.13657)》提出了 **MAST（Multi-Agent System Failure Taxonomy）** 分类法，为我们提供了一套结构化的诊断方法。

#### MAST 失败分类表

MAST 将 14 种失败模式归纳为 3 大类别：

| 类别 | 失败模式 | 发生率 | 诊断要点 |
|------|---------|--------|---------|
| **FC1：系统设计问题** | FM-1.1 违反任务规范 | 11.8% | 检查任务定义是否清晰 |
| | FM-1.2 违反角色规范 | 1.5% | 审查角色边界定义 |
| | FM-1.3 步骤重复 | 15.7% | 检查循环计数器和状态更新 |
| | FM-1.4 上下文丢失 | 2.8% | 验证消息传递完整性 |
| | FM-1.5 无法识别停止条件 | 12.4% | 明确终止逻辑 |
| **FC2：智能体间协调失败** | FM-2.1 对话重置 | 2.2% | 检查状态持久化 |
| | FM-2.2 未请求澄清 | 6.8% | 审查歧义处理逻辑 |
| | FM-2.3 任务偏离 | 7.4% | 验证目标一致性 |
| | FM-2.4 信息隐瞒 | 0.85% | 检查信息传递管道 |
| | FM-2.5 忽略他人输入 | 1.9% | 审查消息处理流程 |
| | FM-2.6 推理-行动不匹配 | 13.2% | 对比思考与执行 |
| **FC3：任务验证问题** | FM-3.1 过早终止 | — | 检查终止条件触发 |
| | FM-3.2 验证不完整 | — | 增加验证覆盖 |
| | FM-3.3 验证错误 | — | 审查验证逻辑 |

#### 使用 MAST 进行诊断

当系统失败时，按以下步骤诊断：

1. **收集 Trace**：获取完整的执行轨迹
2. **识别失败点**：定位第一个出现异常的步骤
3. **分类失败模式**：对照 MAST 表匹配失败类型
4. **针对性修复**：根据失败类别采取对应措施

```python
# 示例：基于 MAST 的自动诊断
def diagnose_failure(trace: List[Step]) -> str:
    for i, step in enumerate(trace):
        if step.repeated_count > 3:
            return "FM-1.3 步骤重复：建议增加循环检测"
        if step.context_length < trace[i-1].context_length * 0.5:
            return "FM-1.4 上下文丢失：检查消息截断逻辑"
        if step.action != step.reasoning_intent:
            return "FM-2.6 推理-行动不匹配：审查输出解析"
    return "未识别的失败模式"
```

### 9.2.5 鲁棒性工程：防崩溃指南

除了监控，我们要通过代码设计防止智能体 "发疯"。

#### 循环熔断

智能体本质是 `while` 循环，必须防止它无限空转。

```python
# 必须设置最大步数
agent = create_react_agent(
    model, 
    tools, 
    max_iterations=15  # 超过 15 步强制停止
)

# 必须设置超时
if time.time() - start_time > 60:
    raise TimeoutError("任务执行超时")
```

#### 输出校验

永远不要相信 LLM 输出的 JSON。

- **Pydantic Validation**：
  使用 Pydantic 定义期望的数据结构。如果 LLM 少了字段，Parser 会报错。
  
- **自动修复解析器 (Auto-Fixing Parser)**：
  捕获 Validation Error，把它作为一条新的 System Message 发回给 LLM："你上一步输出的 JSON 格式不对，缺少了 'action' 字段，请修正。" 
  通常 LLM 都能在下一轮自我修正。

#### 错误捕获与反馈

当工具调用失败（如网络超时 500）时，**千万不要抛出异常导致程序崩溃**。

正确的做法是捕获异常，并将其转化为一段自然语言的 **Observation** 反馈给智能体。

```python
def safe_tool_run(query):
    try:
        return api.search(query)
    except Exception as e:
        # 智能体看到这个不仅不会挂，还会尝试换个词搜索
        return f"系统提示：搜索工具调用失败，错误信息：{e}。请尝试缩短关键词重试。"
```

### 9.2.6 成本监控与预算

在企业级应用中，Token 就是钱。

- **Token 计数器**：使用 `tiktoken` 库在每次请求前预估 Cost。
- **预算控制**：为每个 Trace 设置 Budget。
  ```python
  with get_openai_callback() as cb:
      agent.run()
      if cb.total_cost > 1.0:
          stop_processing()
  ```

### 9.2.7 小结

可观测性不仅仅是为了修 Bug，更是为了**理解**。
通过观察 Trace，你会发现 80% 的"不够智能"其实是因为：
1. 检索到的文档不对（RAG 问题）。
2. System Prompt 描述不清（Prompt Engineering 问题）。
3. 工具报错后 Agent 不知所措（鲁棒性问题）。

拥有了可观测性，你才能从"不知所措"变成"有的放矢"。

下一节我们将探讨如何优化性能并控制成本。

---

**下一节**: [性能优化与成本控制](9.3_optimization.md)